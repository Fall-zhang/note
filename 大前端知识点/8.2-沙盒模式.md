---
sidebar_position: 35
---

> Create by **fall** on 2022-08-17
> Recently revised in 2022-08-17

## 沙盒模式

简单来说沙箱（sandbox）就是与外界隔绝的一个环境，内外环境互不影响，外界无法修改该环境内任何信息，沙箱内的东西单独属于一个世界。

把一些不信任的代码运行在沙箱之内，使其不能访问沙箱之外的代码。通常开始可以把 JavaScript 中处理模块依赖关系的闭包称之为沙箱。

## 构建沙盒环境

一般来讲，闭包就是一个沙盒环境

```js
((window)=>{
    var a = 10
    console.log(a) // 10
})(window)
console.log(a) // error ,无法从外部访问到 a
```

模拟原生浏览器对象的目的是为了，防止操作原生对象。

## 注意

闭包时有些内容需要进行注意，

### eval

`eval` 执行的代码可以访问闭包和全局范围，因此就导致了代码注入的安全问题，因为代码内部可以沿着作用域链往上找，篡改全局变量，这不是我们希望的

### new Function

`new Function` 中也存在类似的问题。

```javascript
const sum = new Function('a', 'b', 'return a + b');
console.log(sum(1, 2));//3
var a = 1;

function sandbox() {
    var a = 2;
    return new Function('return a;'); // 这里的 a 指向最上面全局作用域内的 1，不是作用域内的 2，违反沙盒的设计要求
}
var f = sandbox();
console.log(f())
```

 Function 创建的函数只能在全局作用域中运行。它无法访问局部闭包变量，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造器创建时所在的作用域的变量；但是，它仍然可以访问全局范围。

### with

```js
function sandbox(o) {
  with (o){
    c=2;
    d=3;
    console.log(a,b,c,d); // 0,1,2,3 // 每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性
  }
}
var f = {
  a:0,
  b:1
}
sandbox(f);       
console.log(f);
console.log(c,d); // 2,3  c、d 被泄露到 window 对象上可以全局访问了
```

关键字 `with` 带来了内存泄漏，如果 with 内（块作用域）有值，就会在 with 内寻找，如果没有

在非严格模式下，会自动在全局作用域创建一个全局变量

### in

```js
var o = {  
  a : 1,  
  b : function() {}
}
console.log("a" in o);  //true
console.log("b" in o);  //true
console.log("c" in o);  //false
console.log("valueOf" in o);  //返回true，继承Object的原型方法
console.log("constructor" in o);  //返回true，继承Object的原型属性
```

可以通过 in 间接读取到原型上的方法，和属性

## 参考文章

| 作者              | 链接                                       |
| ----------------- | ------------------------------------------ |
| 袋鼠云数栈UED团队 | https://juejin.cn/post/6976828400572842014 |
