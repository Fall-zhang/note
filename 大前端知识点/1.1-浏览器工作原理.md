---
sidebar_position: 11
---

> Create by **fall** on 2020----
> Recently revised in 2021----

## 浏览器工作原理

### 浏览器的组成

- 人机交互部分（UI）
- 网络请求部分（Socket)
- javascript 引擎部分(解析执行javascript)
- 渲染数据部分(渲染HTML、CSS)
- 数据存储部分(cookie、HTML5中本地存储、localstorage、sessionStorage)

> 服务器负责找到文件，并将文件的数据返回给浏览器
>
> 当静态页面改变时，不用重启服务器就可以实现**静态页面**的重新加载，因为只是对于网页的引用。

### 请求和响应报文

|  Request   |   Responses    |
| :--------: | :------------: |
|   请求行   |     响应行     |
| 请求报文头 | HTTP响应报文头 |
| （空一行） |   （空一行）   |
| 请求报文体 |   请求报文体   |

请求行：请求方法，请求路径，请求所使用的 HTTP 协议

响应行：HTTP协议，协议版本，HTTP状态码，状态码对应的消息

### 渲染工作原理

**主流渲染引擎**

渲染引擎又叫排版引擎或浏览器内核

- **Chrome浏览器**: Blink引擎(WebKit的一个分支)
- **Safari浏览器** WebKit引擎， windows版 本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari 
- **FireFox浏览器**: Gecko引擎。
- **0pera浏览器**: Blink引擎(早期版使用Presto引擎) 。
- **Internet Explorer浏 览器**: Trident引 擎。
- **Microsoft Edge浏览器**: Blink引擎

> **ChromeV8引擎**
>
> 只有堆(HEAP)和栈(STACK)
>
> 单线程等于一个调用栈，一次只能执行一件事

> 浏览器会解析三类内容
>
> - HTML/SVG/XHTML，描述一个页面的结构，浏览器会把HTML结构字符串转换成DOM树形结构
> - CSS，解析CSS生成CSS规则树
> - javascript 脚本，加载后，通过 DOM API 和 CSS API 操作 DOM 树和 CSS 树

**构建DOM**

> 数据是以字节的方式在网络传输，从服务器传输到本地后，字节数据根据指定编码转化为字符串，字符串转换为Token(标记)，转化为Node(节点对象)，再转化为DOM
>
> Token:例如：`<html>`、`<body>`等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。
>
> 一边生成token，一边消耗token生成节点对象

 **构建CSSOM**

> CSS 文件的解析方式类似于构建DOM，字节数据根据指定编码转化为字符串，字符串转换为Token(标记)，转化为Node (节点对象)，再转化为CSSOM。
>
> CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情。所以，DOM 树要小，CSS尽量用 id 和 class，千万不要过渡层叠下去。

**构建渲染树**

> 生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。渲染树只会包括需要显示的节点和这些样式节点的信息。比如`display:none`的元素不会于渲染。
>
> 如果渲染过程中遇到JS文件(script标签)就停止渲染，JS文件不只是阻塞DOM的构建，也会导致CSSOM阻塞DOM的构建。所以，如果想让首屏加载得更快，就不应该在首屏加载JS文件。

**布局与绘制**

> 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
>
> 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。
>
> 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

### 单线程的异步非阻塞IO操作

> **async和defer的作用**
>
> **正常加载模式**：
>
> `<script src="script.js"></script>`
>
> 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，读到脚本就加载并执行。
>
> **异步下载**：
>
> `<script async src="script.js"></script>`  
>
> **async**表示异步执行JavaScript，无论此刻是*HTML*解析阶段还是*DOMContentLoaded*触发之后，如果已经加载好，就会开始执行。但是这种方式加载的 JavaScript 依然会阻塞 load 事件。*async-script*可能在*DOMContentLoaded*触发之前或之后执行，但一定在*load*触发之前执行。
>
> *load事件*：当整个页面及所有依赖资源如样式表和图片都已完成加载时触发，`window.onload`
>
> **延迟执行**：
>
> `<script defer src="script.js"></script>`
>
> **defer**属性表示延迟执行引入的JavaScript，即这段JavaScript加载时HTML并未停止解析，这两个过程是并行的。整个document解析完毕且defer-script也加载完成之后（这两件事情的顺序无关），会执行所有由defer-script 加载的JavaScript代码，然后触发DOMContentLoaded事件。
>
> defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到HTML 标签解析完成之后。在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。

详情点击该[视频教学](https://www.bilibili.com/video/BV1GE411L7is?p=15)   https://www.bilibili.com/video/BV1GE411L7is?p=15

[单线程异步实现的代码演示](http://latentflip.com/loupe) http://latentflip.com/loupe

### DOM操作为什么慢

> JS 很快，在 JS 中修改 DOM 也很快。但是 DOM 是属于渲染引擎的，而 JS又是JS引擎的东西，两个引擎之间的交流，实现起来并不容易。 
>
> 而每次JS对DOM进行操作开销会不小，为了减少性能问题，避免大量对DOM操作。

### 回流和重绘

回流：**Reflow**

> 当对 DOM 引发了 DOM 尺寸的变化，（宽、高、隐藏（display:none））浏览器就要重新计算元素的几何属性，将结果绘制出来。回流时其他元素也会受到影响。

重绘：**Repaint**

> 导致样式发生变化，却没有影响几何属性（没有修改长宽高，只修改背景颜色 invisible 等，），此时浏览器不需要计算元素的几何属性，直接为改样式绘制新的样式。

**如何有效减少回流**

> - 使用 transform 替代 top
> - 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
> - 不要把节点的属性值放在一个循环里当成循环里的变量。
>
> ```js
> for(let i = 0; i < 1000; i++) {
>     // 获取 offsetTop 会导致回流，因为需要去获取正确的值
>     console.log(document.querySelector('.test').style.offsetTop)
> }
> ```
>
> - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
> - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
> - CSS 选择符从右往左匹配查找，避免节点层级过多
> - 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。



> - 浏览器工作流程：构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。
> - CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。
> - 通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个不带defer或async属性的script标签时，DOM构建将暂停，如果此时又恰巧浏览器尚未完成CSSOM的下载和构建，由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS，最后才重新DOM构建。
>
> **注：**
>
> 回流必定发生重绘，回流所需的成本比重绘高的多，改变父节点里面的子节点，可能导致一系列回流

## 数据是如何存储的

栈空间和堆空间

**动态语言**：在使用时需要检查数据类型的语言。

**弱类型语言**：支持隐式转换的语言。

JavaScript 中的 8 种数据类型，它们可以分为两大类——**原始类型和引用类型。**


原始类型数据存放在栈中，引用类型数据存放在堆中。堆中的数据是通过引用与变量关系联系起来的。

**从内存视角了解闭包**：词法扫描内部函数，引用了外部函数变量，堆空间创建一个“closure”对象，保存变量。

## Chrome 架构：仅仅打开了 1 个页面，为什么有 4 个进程

**线程和进程区别**：多线程可以并行处理任务，线程不能单独存在，它是由进程来启动和管理的。一个进程是一个程序的运行实例。

**线程和进程的关系**：

- 进程中任意一线程执行出错，都会导致整个进程的崩溃。
- 线程之间共享进程中的数据。
- 当一个进程关闭后，操作系统会回收进程所占用的内存。
- 进程之间的内容相互隔离。

**单进程浏览器**：

1、不稳定。单进程中的插件、渲染线程崩溃导致整个浏览器崩溃。

2、不流畅。脚本（死循环）或插件会使浏览器卡顿。

3、不安全。插件和脚本可以获取到操作系统任意资源。

**多进程浏览器**：

1、解决不稳定。进程相互隔离，一个页面或者插件崩溃时，影响仅仅时当前插件或者页面，不会影响到其他页面。

2、解决不流畅。脚本阻塞当前页面渲染进程，不会影响到其他页面。

3、解决不安全。采用多进程架构使用沙箱。沙箱看成时操作系统给进程上来一把锁，沙箱的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据。

**多进程架构**：分为 浏览器进程、渲染进程、GPU 进程、网络进程、插件进程。

**缺点**：

1、资源占用高。

2、体系架构复杂。

**面向服务架构**：把原来的各种模块重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 通讯，使得系统更内聚、松耦合、易维护和拓展。

## HTML、CSS 和 JavaScript 是如何变成页面的

- 浏览器不能直接理解 HTML 数据，需要将其转化为 DOM 树结构；
- 生成 DOM 树后，根据 CSS 样式表，计算出 DOM 树所有节点样式；
- 创建布局树：遍历 DOM 树所有可见节点，把这些节点加到布局中，不可见节点忽略，如 head 标签下所有内容，display: none 元素；



- 分层：层叠上下文属性的元素（比如定位属性元素、透明属性元素、CSS 滤镜属性元素）提升为单独的一层，需要裁剪的地方（比如出现滚动条）也会被创建为图层；
- 图层绘制：完成图层树构建后，渲染引擎会对图层树每一层进行绘制，把一个图层拆分成小的绘制指令，再把指令按照顺序组成一个带绘制列表；
- 有些情况图层很大，一次绘制所有图层内容，开销太大，合成线程会将图层划分为图块（256x256 或者 512x512）；
- 合成线程将图块提交给栅格线程进行栅格化，将图块转换为位图。栅格化过程都会使用 GPU 加速，生成的位图保存周期 GPU 内存中；
- 一旦所有图块都被栅格化，合成线程会生成一个绘制图块命令（DrawQuad），然会将命令提交给浏览器进程，viz 组件接收到该指令，将页面内容绘制到内存中，显示在屏幕上；
- 重排：通过 JavaScript 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段；重绘：不引起布局变换，直接进入绘制及其以后子阶段；合成：跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程；

## 编译器和解析器：V8 如何执行一段 JavaScript 代码的

- 计算机语言可以分为两种：编译型和解释型语言。编译型语言经过编译器编译后保留机器能读懂的二进制文件，比如 C/C++，go 语言。解释型语言是在程序运行时通过解释器对程序进行动态解释和执行，比如 Python，JavaScript 语言。
- 编译型语言的编译过程：编译器首先将代码进行词法分析、语法分析，生成抽象语法树（AST），然后优化代码，最后生成处理器能够理解的机器码；
- 解释型语言解释过程：解释器会对代码进行词法分析、语法分析，并生产抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后根据字节码执行程序；
- AST 的生成：第一阶段是分词（词法分析），将一行行源码拆解成一个个 token（语法上不可再分、最小单个字符）。第二阶段是解析（语法分析），将上一步生成的 token 数据，根据语法规则转为 AST，这一阶段会检查语法错误；
- 字节码存在的意义：直接将 AST 转化为机器码，执行效率是非常高，但是消耗大量内存，从而先转化为字节码解决内存问题；
- 解释器 ignition 在解释执行字节码，同时会手机代码信息，发现某一部分代码是热点代码（HotSpot），编译器把热点的字节码转化为机器码，并保存起来，下次使用；
- 字节码配合解释器和编译器的计数实现称为即时编译（JIT）。

## 消息队列和事件循环：页面是怎么实现交互的

- 每个渲染进程都有一个主线程，主线程会处理 DOM，计算样式，处理布局，JavaScript 任务以及各种输入事件；
- 维护一个消息队列，新任务（比如 IO 线程）添加到消息队列尾部，主线程循环地从消息队列头部读取任务，执行任务；
- 解决处理优先级高的任务：消息队列的中的任务称为宏任务，每个宏任务中都会包含一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，将该变化添加到微任务队列中；
- 解决单个任务执行时长过久：JavaScript 通过回调功能来规避。

## setTimeout 是怎么实现的

- JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程会创建一个回调任务，延时执行队列存放定时器任务；
- 当定时器任务到期，就会从延时队列中取出并执行；
- 如果当前任务执行时间过久，会影响延时到期定时器任务的执行；
- 如果 setTimeout 存在嵌套调用（5 次以上），判断该函数方法被阻塞，那么系统会设置最短时间间隔为 4 秒；
- 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒，目的是为了降低加载损耗；
- 延时执行时间最大值是 24.8 天，因为延时值是以 32 个 bit 存储的；
- setTimeout 设置的回调函数中的 this 指向全局 window。

## XMLHttpRequest 是怎么实现的

- XMLHttpRequest onreadystatechange 处理流程：未初始化 -> OPENED -> HEADERS_RECEIVED -> LOADING -> DONE；
- 渲染进程会将请求发送给网络进程，然后网络进程负责资源下载，等网络进程接收到数据后，利用 IPC 通知渲染进程；
- 渲染进程接收到消息之后，会将 xhr 回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，会根据相关状态来调用回调函数。

## JavaScript 是如何影响 DOM 树构建的

- HTML 解析器（HTMLParse）负责将 HTML 字节流转换为 DOM 结构；
- HTML 解析器并不是等整个文档加载完成之后再解析，而是网络进程加载流多少数据，便解析多少数据；
- 字节流转换成 DOM 三个阶段：1、字节流转换为 Token；2、维护一个 Token 栈，遇到 StartTag Token 入栈，遇到 EndTag Token 出栈；3、为每个 Token 创建一个 DOM 节点；
- JavaScript 文件和 CSS 样式表文件都会阻塞 DOM 解析；

## 渲染流水线：CSS 如何影响首次加载时的白屏时间？

- DOM 构建结束之后，css 文件还未下载完成，渲染流水线空闲，因为下一步是合成布局树，合成布局树需要 CSSOM 和 DOM，这里需要等待 CSS 加载结束并解析成 CSSOM；
- CSSOM 两个作用：提供给 JavaScript 操作样式表能力，为布局树的合成提供基础样式信息；
- 在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转化为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。