

## HTTP协议

> Create by **fall** on 2021-8-28
> Recently revised in 2021-8-28

无论是`post`还是 `get` 请求，都是基于超文本传输协议，，HTTP协议是TCP/IP协议的应用层协议。

请求格式包括以下格式：请求行，请求头部、空行，请求数据

响应也由四个部分组成，分别是响应行，响应头，空行，响应体

请求方法有以下几种：

- get：获取资源，用来请求访问已经被URI识别的资源（URI是统一资源标识符，同URL是包含和被包含的关系）
- post：用来传输实体的主体（get也可以实现，但一般不适用get）
- put：传输文件，put方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，都不实用该方法进行上传文件。
- HEAD：获得报文首部，同 `get` 请求，只是不返回报文主体部分
- DELETE：删除文件，同样不带验证机制，存在安全性问题。
- OPTIONS：询问指定的请求 `URI` 支持那些方法，post请求时，浏览器会先发一次 options 请求，如果请求通过，则正式发送 post 请求
- TRACE：追踪路径，让Web服务器将之前的请求通信还回给客户端的方法。
- CONNECT：要在请求与代理服务器通信时建立隧道，实现隧道进行TCP通信

## `get`和 `post` 的特点

一般来讲，`get`和`post`的特点

| 特点           | `get`                                  | `post`                         |
| -------------- | -------------------------------------- | ------------------------------ |
| 请求参数       | 参数通过URL进行传递，多个参数通过&连接 | 请求参数放在 request body中    |
| 请求缓存       | `get`请求会被缓存                      | 请求不会被缓存为历史记录       |
| 收藏为书签     | 可以                                   | 不可以                         |
| 安全性         | 比较不安全                             | 比较安全                       |
| 浏览器回退     | 参数会被完整地保留在浏览器记录，且无害 | 参数不会被保留，会再次进行请求 |
| 编码方式       | `get`请求只能进行URL编码               | 支持多种编码格式               |
| 参数的数据类型 | 只接受ASCII字符                        | `post`没有限制                 |

## POST & GET 常见误区

- **请求参数长度限制？**

HTTP协议中没有对URL长度进行限制，限制是不同的浏览器和服务器有不同规范带来的限制。

限制长度有两方面的考虑，第一，防止恶意传入过多数据对服务器的响应造成压力。巴高速服务器Content-Length是一个很大的数，却只发送一点数据，让服务器傻等。哪怕有超时设置，还会因为故意的访问超时让服务器瓦特。

因此无论是post还是get，浏览器都会给相应的URL长度限制

- **`get`请求不能有request body传输数据？**

`get`可以带 request body 但是不一定能保证被接收到。如果使用get时，在`request body`藏了数据，不同的服务器处理方式是不同的，有的服务器会帮你读出数据，而另一些服务器会直接进行忽略。

`post` 、`get`请求都是由 HTTP协议制定的，**使用哪个 method 与应用层的数据如何进行传输，没有相互关系。** 

`HTTP`协议没有要求如果是post 就将数据放在 body中，也没有要求如果是get，统一将数据放在 URL中。

`HTML`中的约定是将这些数据放在相应的位置，但是又不是所有的请求都依赖于`HTML`。

- **`post`比`get`安全性更高？**

安全性是相对的，通过`get`提交的数据都会显示在URL上， 页面的URL会在历史记录里面，她人查看历史记录，会看到提交的记录，`post`不会，`get`提交数据可能会造成CSRF攻击。

- `get`请求时产生一个TCP数据包，`post`产生两个数据包？

对于`get`请求而言，浏览器会把`http header` 一起发送出去，服务器返回 `200` `OK`

对于`post`而言，浏览器先发送 `Header`，服务器先响应`100` `continue` 浏览器再发送 `data`，服务器响应 `200`，但是这种情况虽然`post`会请求两次，`body`是紧跟`header`进行发送的，根本不存在等待服务器响应。

导致`post`连续发送两次请求可能原因是`post`可能传输大量的数据，如果服务器没有处理 `100`，而是其他的情况，可能导致浪费大量带宽。

## 如何保证数据安全

HTTPS（Hyper Text Transfer Protocol Secure）

以HTTP 为基础，提供额外验证，即，HTTP+ Secure

实际使用中，会使用很多信息，最常用的是

客户端请求时，会先发送

- 所访问的网站
- 所支持的算法
- 生成的随机数

相应时，会采用以下答复

- 所给出的算法中，选出一种算法
- 也会生成一个随机数
- 网站的证书

**网站证书**：

- 包含证书的使用者，颁发给了那个网站或者是使用者
- 证书的有效期
- 一个公钥
- 证书的颁发者

证书可以证明你拥有了一个可以确定某某人的证明

在所有聊天记录都被偷看的情况下，交换了密钥。



## 参考文章

| 作者                                                | 连接                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| [少侠露飞](https://segmentfault.com/u/shaoxialufei) | https://segmentfault.com/a/1190000023940344                  |
| [木-叶](https://www.cnblogs.com/nankezhishi/)       | https://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html |
|                                                     |                                                              |



