---
sidebar_position: 43
---

> Create by **fall** on 2022-05-19
> Recently revised in 2022-05-20

## 内存

三个主要的 Node 内存消耗区域：

- 代码 - 代码被执行的地方
- 调用栈（栈内存）函数和基础数据类型的局部变量（number，string）
- 堆内存

现在，在堆上分配一些内存

```js
// 模拟字节数的分配
function allocateMemory(size) {
  const numbers = size / 8;
  const arr = [];
  arr.length = numbers;
  for (let i = 0; i < numbers; i++) {
    arr[i] = i;
  }
  return arr;
}
const memoryLeakAllocations = [];
const field = "heapUsed";
const allocationStep = 10000 * 1024; // 10MB
const TIME_INTERVAL_IN_MSEC = 40;
setInterval(() => {
  const allocation = allocateMemory(allocationStep);
  memoryLeakAllocations.push(allocation);
  const mu = process.memoryUsage(); // process.memoryUsage 是一个收集堆利用率指标的原生工具。
  // # bytes / KB / MB / GB
  const gbNow = mu[field] / 1024 / 1024 / 1024;
  const gbRounded = Math.round(gbNow * 100) / 100;
  console.log(`Heap allocated ${gbRounded} GB`);
}, TIME_INTERVAL_IN_MSEC);

```

通过该方法实现每隔 40 毫秒分配 10 MB 左右内存，这给垃圾回收足够的时间，将存活的对象晋升到老生代中。

在一台内存为 32GB 的搭载 Windows 10 操作系统的笔记本电脑上，垃圾回收器在放弃并抛出“内存栈溢出”异常之前，会尝试压缩内存作为最后手段。这个进程用了 26.6s 达到了 4.1GB 的内存限制，此时它意识到是时候终止了。V8 垃圾回收器一开始运行在具有严格内存限制的 32 位的浏览器进程中。这些结果暗示内存限制也许来自遗留代码。

## 内存泄露

**内存泄漏**（Memory Leak）

随着应用的处理，可能持有越来越多的无用内存，这些无用的内存变多会引起服务器响应速度变慢，严重的情况下导致内存达到某个极限（可能是进程的上限，如 v8 的上限；也可能是系统可提供的内存上限）会使得应用程序崩溃。

JS 中常见的内存泄漏有四种原因：

- 全局变量
- 闭包
- DOM 元素的引用
- 定时器

### 如何分析内存泄露

依次梳理对象的引用，如果能从 root 的引用链到达访问，V8 就会将其标记为**可到达对象**，反之为**不可到达对象**。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。

在 Node.js 中内存泄露的原因就是本该被清除的对象，被可到达对象引用以后，未被正确的清除而常驻内存。





## 参考文章

| 作者       | 链接                                       |
| ---------- | ------------------------------------------ |
| CarlosChen | https://juejin.cn/post/7087578623393136670 |

