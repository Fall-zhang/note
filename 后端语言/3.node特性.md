## 事件循环

事件循环阐明了 Node.js 如何做到异步且具有非阻塞的 I/O 

JavaScript 代码运行在单个线程上，每次只处理一件事。简化了编程方式，不用考虑并发问题。

只要注意如何编写代码，并且避免任何可能阻塞线程的事情，例如同步的调用或无限的循环，

大多数浏览器中，每个浏览器选项卡都有一个事件循环，使每个进程都隔开，避免一个网页繁重的处理影响到整个浏览器的网页。

### 阻塞事件循环

任何花费太长时间才能将控制权返回给事件循环的 JavaScript 代码，都会阻塞页面中任何 JavaScript 代码的执行，甚至阻塞 UI 线程，并且用户无法单击浏览、滚动页面等。

JavaScript 中几乎所有的 I/O 基元都是非阻塞的。 网络请求、文件系统操作等。 被阻塞是个异常，这就是 JavaScript 如此之多基于回调（最近越来越多基于 `promise` 和 `async/await`）的原因。

> 总结：除 `setTimeout` 和异步操作外，其它函数执行完成之后，再开始执行计时器或者异步操作的函数

### 事件循环函数

每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。

`process.nextTick()`

当将一个函数传给 `process.nextTick()` 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数。**简单来讲，会把函数放置到下一个循环执行**。

 `setTimeout()` 内的函数会在下一个滴答结束时执行，比使用 `nextTick()`（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。

```js
process.nextTick(()=>{console.log("199")})
// nextTick内传入的为函数
console.log("pei")
setTimeout(()=>{console.log("999")},0)
// 执行后输出顺序为 pei 199 999
```

`setImmediate()`

传入的任何函数都是在事件循环的下一个迭代中执行的回调

延迟 0 毫秒的 `setTimeout()` 回调与 `setImmediate()` 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。

某些浏览器实现了`setImmidate()`的功能，并且其它浏览器上不可用，在node.js中是标准的函数。

```js
setImmediate(()=>{
	console.log("996")
})
```

`setTimeout()`

定时器的使用

根据HTML5的标准，`setTimeout()`最少为4ms

```js
// 第一个传入执行的函数，第二个参数传入事件（单位毫秒）
// 返回值是该定时器的id，通常不会使用，但是可以保存
var id = setTimeout(()=>{console.log("beautiful")},2000) // 如果后面再继续传参，会认为是定时函数的参数
clearTimeout(id)
```

`setInterval()`

在指定的时间间隔内执行函数

```js
var ss = setInterval(()=>{
  // 执行的函数
},2000)
clearInterval(ss)
```

## 异步管理Promise

异步函数在底层使用了 `promise`，了解Promise的工作方式是了解 `async` & `await` 的基础。

Promise 是用来管理异步编程的，**它本身不是异步的**，Promise用于防止陷入回调地狱。

当 promise 被调用后，它会以处理中状态开始，此时调用的函数会继续执行，而 promise 仍在处理中直到解决为止，从而为调用的函数提供所请求的任何数据。被创建的 promise 最终会以**被解决状态或被拒绝状态**结束，并在完成时调用相应的回调函数（传给 `then` 和 `catch`）。

那些JS API 使用了 promise?

- Battery API
- Fetch API
- Service Worker

**Promise 的使用**

```js
var p = new Promise(function(resolve, reject) {
  if (/* condition */) {
    // fulfilled successfully
    resolve(/* value */);  
  } else {
    // error, rejected
    reject(/* reason */);  
  }
});
// 方法一：p.then()内传入方法，
// 第一个方法执行成功后执行 resolve 中的函数
// 第二个方法执行方法的传入值为 reject 的参数 
p.then(()=>{
  /* 成功后的执行内容 */
},()=>{
  /* 失败后的执行内容 */
})
// 方法二：成功的内容通过.then()获取。失败的内容也可以通过 .catch() 进行捕获
p.catch((err)=>{throw new Error('错误')})
.catch(err)=>{console.log(err)}
// 如果捕获错误中出现错误，可以添加第二个catch来补获
```

> 在 promise 中的错误会像冒泡一样，如果出现一个错误，那么接下来的也都会错误。但可以利用这一特性——在最后调用的接口上实现对于错误的处理，实现简化错误操作。
>
> 注：实现该特性需要两点注意，第一点每次调用 then 都要返回一个新的 Promise ；不管第一个参数的返回值是什么，

> 是否执行 `reslove` , `reject` 都是取决于是否执行 `reslove()` & `reject()` 或者是函数本身出现异常

**当执行的函数出现错误时**

```js
new Promise(resolve=>{
  resolve(a)
  // 由于 a 没有定义，所以执行错误返回
}).then(result=>{
  console.log("成功"+result)
},reason=>{
  console.log("失败"+reason)
}).then(result=>{
  console.log("success"+result)
},reason=>{
  console.log('failure')
})
// 该函数第一次执行失败，调用失败的函数
// 第二次由于没有返回值，以成功执行计算
// 个人理解，第一个 then 判断的是 Promise 对象执行成功与否，第二个 then 用来判断第一个 then 执行的成功与否
```

> Promise 能解决回调地狱的问题，但是由于充满了 then 方法，使得可读性不强，所以使用 `async & await` 作为语法糖，很多人认为 `async & await` 就是回调地狱的最终解决方案。

**Promise 的嵌套调用**

```js
const pr = new Promise((resolve) => {
  setTimeout(() => {
    console.log(999)
  }, 1000)
  resolve('666')
})
pr.then((result) => {
  console.log("1111"+result)
  return Promise.resolve("bbbb")
  /* 等价于 
	new Promise(resolve=>{
		resolve("bbbb")
	})
*/
})
  .then((result) => {
    console.log('吃人的东西'+result)
  })
  .catch((err) => {
    console.log('出错了，玛德' + err)
  })

```

### Promise 的方法

`Promise.resolve()` 返回一个给定值解析后的 Promise 对象

`Promise.resolve('foo')` 

等价于`new Promise(resolve => resolve("foo"))`

## 现代异步async & await

`async/await` 的实现是基于 Promise的，`async` 关键字意味着该函数会返回 `promise`，是 generator 的语法糖。

```js
const fun1 = async()=>{
  return '测试'
}
fun1().then(alert)
// fun1 等价于 fun2
const fun2 = ()=>{
  return Promise.resolve('测试')
}
```

只有 await 右边返回为 resolve 才会继续执行，否则直接中断

```js
let p1 = Promise.reject(100)
async function fn1() {
  let result = await p1
  console.log(1) // 这行代码不会执行
}
```

- 语法简洁，更像是同步代码，也更符合普通的阅读习惯；
- 改进JS中异步操作串行执行的代码组织方式，减少callback的嵌套；
- Promise 中不能自定义使用 `try/catch` 进行错误捕获，但是在 `async/await` 中可以像处理同步代码处理错误。

await 将异步代码改造成了同步代码，这会导致多个异步代码**没有依赖性却使用了 await 会导致性能上的降低**。

await 意思是，等待 await 里面的函数全部执行完成，再接着执行该函数。在接着执行函数之前，先执行其他函数。

```js
let p1 = Promise.resolve(1)
let p2 = new Promise(resolve=>{
  setTimeout(()=>{
    resolve(2)
  },2000)
})
async function fun(){
  console.log(1)
  let resu2 = await p1 // 等待返回 resolve ,返回 resolve 后继续执行
  console.log(3)
  let resu1 = await p2
  console.log(4)
}
fun()
console.log(2)
```

> 任务队列（宏任务）
>
> 基于微任务的技术有 `MutationObserver`、`Promise` 以及以 `Promise` 为基础开发出来的很多其他的技术。
>
> 不管宏任务是否到达时间，以及放置的先后顺序，每次**主线程执行栈为空的时候**，引擎会优先处理微任务队列，**处理完微任务队列里的所有任务**，再去处理宏任务。

```js
let p1 = Promise.resolve(1)
let p2 = new Promise(resolve=>{
  setTimeout(()=>{
    resolve(2)
  },2000)
})
async function fun(){
  console.log(1)
  let resu2 = await p1
  console.log(3)
  let resu1 = await p2
  console.log(4)
}
fun()
console.log(2)
```

根据HTML5 的标准，`setTimeout()`最少为 4ms

## 事件触发器

在后端，使用 events 构建类似于前端的类似的系统选项

```js
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 
```

 