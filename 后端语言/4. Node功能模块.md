## **path**

相对于当前执行文件时的路径，而不是该文件的目标路径

解决方法

> - `__dirname` 当前 `.js` 文件所在的目录
>
> - `__filename` `__dirname` + 当前文件名
>
> > 这两个变量并不是全局使用的，只不过是执行文件时有个沙箱，将文件放在沙箱中执行，沙箱提供了该功能 

路径之中由于 `linux` 和 `windows`，MacOS的不同路径解析方式，通过 path 中的 join 进行拼接。

```js
var path = require('path')
path.join(__dirname,'hello.txt')
```

> 文件操作时，无需判断文件是否存在，直接进行操作，如果不存在会反映在error对象中


 ## File System(fs)

> 对于服务器来说，每一个文件都要设置相应的请求，如果不设置相应的请求，直接会设置为请求失败。
>
> 并且要设置每一个类型的请求的返回文件的格式。

作用：用于处理文件操作

书写格式：`fs.writeFile(file, data[, options], callback)`

### 写入文件

写入文件的方法1

```js
var fs = require('fs');
fs.writeFile('./hello.txt',msg,'utf8',function(err){
    if(err){
        console.log('写入文件出错：'+ err);
    }else{
        console.log('writen successful');
    }
})
```

指定写入文件的方法

- `r+` 打开文件用于读写。
- `w+` 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。
- `a` 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。
- `a+` 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。

```javascript
fs.writeFile('/Users/joe/test.txt', content, { flag: 'a+' }, err => {})
```

追加文件可以直接通过 

`fs.appendFile('fileName',content,'utf-8',err=>{})`

### 读取文件

书写格式：`fs.readFile(path[, options], callback)`

```js
var fs = require('fs');
// 读取文件
fs.readFile('./hello.txt','utf8',function(err,data){
    if(err){
        throw err;
    }
    console.log(data);
})
```

## URL

通过 URL 来查询和控制域名相关的。

**URL 的构成**

```text
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                            href                                             │
├────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬──────┤
│protocol│  │        auth         │          host          │           path            │ hash │
│        │  │                     ├─────────────────┬──────┼──────────┬────────────────┤      │
│        │  │                     │    hostname     │ port │ pathname │     search     │      │
│        │  │                     │                 │      │          ├─┬──────────────┤      │
│        │  │                     │                 │      │          │ │    query     │      │
" https:  //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string  #hash "
│        │  │          │          │    hostname     │ port │          │                │      │
│        │  │          │          ├─────────────────┴──────┤          │                │      │
│protocol│  │ username │ password │          host          │          │                │      │
├────────┴──┼──────────┴──────────┼────────────────────────┤          │                │      │
│  origin   │                     │         origin         │ pathname │     search     │ hash │
├───────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴──────┤
│                                            href                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

> 注：`URL` 对象的所有属性都是在类的原型上实现为 getter 和 setter，而不是作为对象本身的数据属性。因此，与[传统的urlObjects](http://nodejs.cn/api/url.html#url_legacy_urlobject)不同，在 `URL` 对象的任何属性(例如 `delete myURL.protocol`， `delete myURL.pathname`等)上使用 `delete` 关键字没有任何效果，但仍返回 `true`。

## mime

非官方组件，需要通过`npm install mime` 安装

mime可以将文件的格式返回成为对应的 mime-type

## http

### 创建简单的服务器

首先需要引入 http 模块 `const http = require('http');`

```js
const http = require('http');
var sever = http.createServer(function(req,res){
    res.setHeader('Content-Type','text/plain;charset=utf-8');
    res.write('hello world 第二个程序');
    res.end()
}).listen(8080,function(){
    console.log('服务器部署成功，端口号:8080')
})
```

> http 模块中常用的对象
>
> request 对象包含了用户请求报中所有内容，通过 request 对象和可获取所有用户提交过来的数据，一般在使用时会简写为 `req`
>
> `response` 对象用来向用户想硬一些数据，当服务器要向客户端进行响应的时候必须使用 response 对象，简写为 `res`
>
> 有了 request 对象和 response 对象，既可以获取用户提交的数据，也可以向用户响应数据

### Request 对象

> request对象的API：
>
> 在文档中是 `http.IncomingMessage`
>
> - `request.headers`：请求报文头
> - `request.rawheaders`：请求报文头（原生请求报文头）
> - `request.httpVersion`：http协议的版本号
> - `request.method`：请求的方法（get、post、delete）
> - `request.url`：请求的路径

```js
const http = require('http')
const port = 8081
http.createServer(function(req,res){
  console.log(req.headers) // 打印请求报文头，报文头以对象的形式进行存储
  console.log(req.rawheaders) // 打印请求报文头，打印出以数组的形式存储的字符串
  console.log(req.httpVersion) // 打印HTTP协议的版本
  console.log(req.method) // 返回请求的方法
  console.log(req.url) // 打印请求的路径
  res.end('that is all')
  // 请求一般产生两次，一次是文件读取，另一次是favicon.ico
}).listen(port,function(){
  console.log('http:localhost:'+port)
})
```

### Response 对象

> response对象的API：
>
> 文档中对应的是 `http.ServerResponse`
>
> - `res.write(chunk[,encoding][,callback])` 
> - `res.end()` 每个方法都要添加，用于结束本次请求（该方法会告诉服务器，所有响应头和主题都已经被发送，服务器将其视为已完成）。
> - `res.setHeader()` 设置响应报文头，如果不设置，系统会自动设置，如果设置的覆盖了系统的响应头，则以设置的为基准
> - `res.statusCode` 设置对应的状态码
> - `res.statusMessage` 设置对应的状态码的消息
> - `res.writeHead()` 直接向客户端写入响应报文

```js
const http = require('http')
http.createServer((req,res)=>{
  // end 函数如果指定了 data ，相当于调用了 res.write(data,encoding)之后再调用res.end(callback)
  res.statusCode = 404 // 放置在setHeader前面，用于返回响应状态码
  res.statusMessage = 'Not Found' // 返回状态码对应的消息
  res.setHeader('Content-Type','text/plain;charset=utf-8') // setHeader 必须放在 res.end()之前，否则不会生效且报错
  // 此处的 writeHead 相当于 statusCode statusMessage steHeader 三个合起来写入，这三个功能其实是写入对应 setHeader 里面的值
  // res.writeHead(404,'not found',{
  //   "Content-Type":"text/plain;charset=utf-8"
  // })
  res.write('hello you beach')
  res.end()
}).listen(8082,function(){
  console.log('http://localhost:8082')
})
```

`setHeader`：可以设置不同响应报文头，对浏览器传达不同的信息或者指令。

```js
res.setHeader('Location',"/")
```

