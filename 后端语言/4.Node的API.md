## path

相对于当前执行文件时的路径，而不是该文件的目标路径

解决方法

> - `__dirname` 当前正在执行的 JS 所在的目录
>
> - `__filename` 当前正在执行的文件的目录
>
> > 这两个变量并不是全局使用的，只不过是执行文件时有个沙箱，将文件放在砂箱中执行，沙箱提供了该功能 

路径之中由于 `linux` 和 `windows`，MacOS的不同路径解析方式

> 获取路径API`var path = require('path')`

```js
var path = require('path')
path.join(__dirname,'hello.txt')
```

> 文件操作时，无需判断文件是否存在，直接进行操作，如果不存在会反映在error对象中

## http

### 声明

var http = require('http');

> 监听用户请求事件
>
> - request 对象包含了用户请求报中所有内容，通过request对象和可获取所有用户提交过来的数据
> - sesponse 对象用来向用户想硬一些数据，当服务器要向客户端相应的时候必须使用response对象
> - 有了request对象和response 对象，既可以获取用户提交的数据，也可以向用户响应数据

```js
var sever = http.createServer();
sever.on('request',function(request,resopnse){
    resopnse.setHeader('Content-Type','text/plain;charset=utf-8');
    // text/plain  可以更换为text/html
    resopnse.write('hello world 第一个程序');
    resopnse.end()
})
```

### 简写

```js
var http = require('http');
var sever = http.createServer(function(req,res){
    res.setHeader('Content-Type','text/plain;charset=utf-8');
    res.write('hello world 第二个程序');
    console.log(req.url)
    res.end()
}).listen(8080,function(){
    console.log('服务器部署成功，端口号:8080')
})
```

 ## File System(fs)

> 对于服务器来说，每一个文件都要设置相应的请求，如果不设置相应的请求，直接会设置为请求失败
>
> 并且要设置每一个类型的请求的返回文件的格式

用于处理文件操作

书写格式：`fs.writeFile(file, data[, options], callback)`

写入文件

```js
var fs = require('fs');
fs.writeFile('./hello.txt',msg,'utf8',function(err){
    if(err){
        console.log('写入文件出错：'+ err);
    }else{
        console.log('writen successful');
    }
})
```

读取文件

书写格式：`fs.readFile(path[, options], callback)`

```js
var fs = require('fs');
// 读取文件
fs.readFile('.hello.txt','utf8',function(err,data){
    if(err){
        throw err;
    }
    console.log(data);
})
```

## mime

非官方组件，需要通过`npm install mime` 安装

mime可以将文件的格式返回成为对应的 mime-type



