> 创建时间：2021-02-28
> 更新时间：2021-09-15

## 模块化概述

传统开发在开发过程中，会遇到函数命名冲突和文件依赖等问题

**模块化开发**用于解决这些问题

单独地将一个功能封装到模块（文件）中，模块之间相互隔离，通过特定的接口公开内部成员，或者引入别的模块

这样开发可以方便代码重用，提升开发效率，并且方便后期维护。

> CommonJS规范，是应用于服务器的规范，
>
> AMD规范，CMD规范都是应用于浏览器端的规范
>
> 这些规范都是由社区提出，并不是通用的模块化规范，所以提出了ES6模块化规范

## CommonJS规范

每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。每个模块内部，`module`变量代表当前模块。这个变量是一个对象，它的`exports`属性（即`module.exports`）是对外的接口。

`require()`方法用于加载模块，加载模块时，实际上加载的是 `module.exports` 属性。

模块分为两种，一是 Node 提供的模块，称为核心模块；二是用户编写的模块，成为文件模块。核心模块（HTTP 模块、URL 模块、FS 模块）在 Node 源代码的编译过程中，编译进了二进制执行文件，所以它的加载速度是最快的。文件模块是在运行时动态加载的，需要完整的路径分析、文件定位、编译执行过程等……所以它的速度相对核心模块来说会更慢一些。

### 使用

node 提供两个对象， exports 和 require 两个对象

**默认导出**

```js
// test.js 文件，用作向外暴露接口
module.exports = function(){
  console.log("这就是调用的东西")
}
// 其他文件使用 test.js
var ss = require("./test")
ss()
```

**普通导出**

```js
// test.js
exports.world = function(){
  console.log('hello')
}
// 其他文件进行使用时
const hello = require('./test.js')
hello.world()
```

require的查找顺序

- 首先在文件模块缓存区
- 是否是原生模块，如果是，并且在文件缓存区，直接加载，不在缓存区进行加载原生模块，然后放入缓存区。
- 查找文件模块，根据扩展名载入，并且进行缓存



- 当前 node.js 仍然使用的是 CommonJS 规范，所以，不支持 `import` 导入其他的包。
- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以被多次加载，但只会运行一次，然后将结果进行缓存，之后调用会直接调用缓存的结果，如果不想再调用，必须清除缓存
- 模块的加载顺序和代码顺序相同。
- CommonJS 规范是服务器规范，一般先下载到本地再调用。
- 读取速度非常，快采用同步的执行方式。

> 浏览器为何不能兼容CommonJS
>
> 缺少四个环境变量：module/exports/require/global

## AMD规范

AMD规范：(客户端 / 浏览器）

```js
// 声明：
define(function(){
  return{
    outA:showA,
    outB:showB
  }
})
// 引入：异步执行
require("moduleA.js",function(moduleA){
  // 在模块引入后执行
  moduleA.outA()
  moduleA.outB()
})
```

> **CMD规范**
>
> 阿里的一名员工编写的规范，已经不使用了

### 规范对比

| 规范     | 相同点         | 不同点                                   |
| -------- | -------------- | ---------------------------------------- |
| AMD规范  | 都是为了模块化 | 非同步加载模块，允许指定回调函数         |
| CommonJS |                | 同步加载，只有加载完成才能完成后面的操作 |



## ECMA6规范

### 导入导出

在规范中定义，每个JS文件都是一个独立的模块。

**导入模块成员**，使用import关键字。暴露模块成员使用 export 关键字。

```js
// tool.js
export function workFlow() {
    console.log('公司是我家')
}
export lovelyNum = '996'
// main.js
import {lovelyNum,workFlow} from './tool.js'
workFlow()
```

进行**命名导入导出**

```js
// tool.js
export function workFlow () {
  console.log('公司是我家')
}
export lovelyNum = '996'
// main.js
import {lovelyNum as luckyNum} from './tool.js'
luckyNum // '996'
```

命名导入导出有时过于繁琐，此时会使用**命名空间导入**

```js
// tool.js
export export function createID () {
  const date = new Date()
  return date.getTime
}
export lovelyNum = '996'
// main.js
import * as creature from './tool.js'
creature.lovelyNum // 996
```

**默认导入组件**

然后就可以使用导出的组件

```js
// moudle.js
let cagg = 233
function app(){console.log(app)}
export default {
  cagg,app
}
// index.js
import app from './moudle.js'
app()
```

**引入直接执行的文件**

使用该方法引入的文件会直接执行

```js
// run.js
console.log('Baidiaoo')
// index.js
import './run.js'
```

## Require.js 语法

对 Require.js 的评价：是实现模块化开发的语法，而模块化开发逐渐淘汰了 Require.js，Require.js 在 MVC 模式开发初期开创了辉煌。

> 注：每一个.html都要一个入口文件：管理当前.html页面使用的所有.js代码
> 注：除了 require.js 的后缀名，其他文件的后缀名都可以省略

```js
// 客户端.js文件遵从AMD规范
// add.js
define(function(){
  function add(x,y){
    return x+y
  }
  function show(){
    console.log('hello world')
  }
  return {
    outAdd:add,
    outShow:show
  }
})
// main.js
// 引入的路径必须为数组
require(["add"],function(getObj){
  var res = getObj.outAdd(1024,2048)
  console.log(res)
})
```

```js
// 实现路径的自动配置
require.config({
  path:{
    // 假设文件路径在demo下的add中
    thePath:'demo/add'
  }
})
require(['thePath'],function(){
  var res = addObj.outAdd(10,20)
  addObj.outShow()
})
```

**子模块使用子模块的方法**

```js
// main.js
require(['path/funA','path/funB'],function(){
  var res = addObj.outAdd(10,20)
  addObj.outShow()
}])
// funA.js
define(function(){
  function addA(a,b){
    return a+b
  }
  return {
    addA:addA
  }
})
// funB.js
define(['path/funA'],function(addA){
  add(10,11)
})
```

