> Create by **fall** on 2021-9-14
> Recently revised in 2021年11月11日11:25:00

## 逻辑运算符

### 基本运算符

- 与运算符`&&`
- 或运算符`||`
- 非运算符`!`

```js
// 与运算符的赋值
const state = true
const content = '这里是一些内容'
const result1 = state && content
const result2 = content && state
result1 // '这里是一些内容'
result2 // t
// 或运算符的赋值
const result1 = true || '996'
const result1 = false || '996'
```

运算符的简写

`x &&=y` 相当于 `x && (x=y)`

`x ||=y` 相当于 `x || (x=y)`

`x ??=y` 相当于 `x ?? (x=y)`

```js
let x = 0
x &&=9   // 0
x ||=12  // 12
x ??=55  // 55
```

### 空值合并运算符

`??` 两个问号

用于解决 `||` 运算符无法应对的情况

```js
let age = 0 || 20
age // 20
let age = '' || null
```

只要转成 `Boolean` 后是 `false`，左侧的值就会被忽略

```js
let age = 0 ?? 20
age // 0
```

该运算符只有左侧为 `null` 或者 `undefined` 会取右侧的值

## 数值分隔符

`_` 可以将数字分割，进行声明，方便查看，可以用于多种进制

> 注：两侧必须都要有数值

```js
let num = 3146_46446 
let num1 = 31_n  // error 错误书写格式
let num2 = 0x_664 // error 错误书写格式
```

## 三步运算符

```js
let x = 10
x>0?x=999:x='wtf'
x // 999
x = x>0?-x:x
x // -999
```

## 可选链操作符

ES2020 引入

`obj.name?.`

```js
let obj = {
  name:{
    firstName:'zhang'
  }
}
obj.name.firstName // 一般是这样取值，但是如果不存在 name 无法取值并且报错
// 为了防止报错通常采用以下两种方法
// 1. 使用 if 进行判断
if(obj){
  if(obj.name){
    let name1 = obj.name.firstName
  }
}
// 2.利用 && 运算符的特性
let name2 = obj && obj.name && obj.firstName
// 用了该符号，一次性解决
let name3 = obj?.name?.firstName 
```



## 展开运算符

Spread syntax，可以进行扩展 

```js
Math.max(...[1,2,3]) // 3
```

### 对象中的应用

可以应用在解构赋值，但是只能应用在最后一个变量上，被接受的值会直接赋值过去，没被接受的会全部复制到展开运算符后的声明数中

```js
let {fall, ...y} = {dear:'55',fall:'23',b:'2',c:3}
y // {b:'2',c:3}
```

实现对象的合并

```js
let a = {name:'fall'}
let b = {age:'23'}
let info = {...a,...b} 
info //{ name: "fall", age: "23" }
```

### 数组中的应用

数组的解构赋值

```js
let [a, b, c = 'c'] = '12'
console.log(a, b, c)  // '1' '2' 'c'
```

### 解构的应用

获取数据类型上的方法

```js
let {toFixed: tf} = 10
// 获取到 10 上的 toFixed 方法，并将该方法赋给 tf
console.log(tf.call(Math.PI, 2))  // 3.14
```

布尔值解构

```js
let {toString: ts} = true
console.log(ts.call(false))  // 'false'
```

数组解构：等号右侧的数据具有 `Iterator` 接口可以进行数组形式的解构赋值；

```js
// 解构不成功的变量值为 undefined
let [a, b, c] = [1, 2]
console.log(a, b, c)  // 1, 2, undefined

// 可以设置默认值
let [x, y, z = 3] = [1, 2, null]
console.log(x, y, z)  // 1, 2, null
复制代码
```

> 什么样的数据具有 `Iterator` 接口呢？如果一个对象能够通过 [Symbol.iterator] 访问，且能够返回一个符合迭代器协议的对象，那么该对象就是可迭代的。目前内置的可迭代对象有：String、Array、TypeArray、Map、Set、arguments 和 NodeList 等。

- 对象解构：与数组按照索引位置进行解构不同，对象解构是按照属性名进行解构赋值，如果在当前对象属性匹配不成功则会去对象的原型属性上查找：

```js
// 默认写法
let { name: name, age: age } = { name: '布兰', age: 12 }
// 简写
let { name, age } = { name: '布兰', age: 12 }
```

  ```js
// 改名且设置默认值
let { name: name1, age: age1 = 12 } = { name: '布兰' }
console.log(name1, age1)  // '布兰' 12
  ```

- 函数参数解构：其实就是运用上面的对象解构和数组解构规则；

  ```js
  function move({x = 0, y = 0} = {}) {
      console.log([x, y])
      return [x, y];
  }
  move({x: 3, y: 8})  // [3, 8]
  move({x: 3})        // [3, 0]
  move({})            // [0, 0]
  move()              // [0, 0]
  ```

**解构要点**：

- 只要等号两边的模式相同（同是对象或同是数组），则左边的变量会被赋予对应的值；
- 解构不成功的变量值为 `undefined`；
- 默认值生效的前提是当等号右边对应的值全等于 undefined 的时候；
- 只要等号右边的值不是对象或者数组，则会进行自动装箱将其转成对象；
- `null` 和 `undefined` 都无法转成对象，所以无法解构。

**解构应用**：

- 交换变量的值；

  ```js
  let x = 1, y = 2;
  [x, y] = [y, x]
  console.log(x, y)  // 2 1
  ```
  
- 通过函数返回对象属性

  ```js
  function getParams() {
      return {
          name: '布兰',
          age: 12,
      }
  }
  let {name, age} = getParams()
  ```
  
- 通过定义函数参数来声明变量

  ```js
  let person = {
      name: '布兰',
      age: 12
  }
  init(person)
  
  // 普通用法
  function init(person) {
      let {name, age} = person
  }
  
  // 更简洁用法
  function init({name, age}) {}
  ```
  
- 指定函数参数默认值

  ```js
  function initPerson({name = '布兰', age = 12} = {}) {
      console.log(name, age)
  }
  initPerson()  // '布兰' 12
  initPerson({age: 20})  // '布兰' 20
  ```
  
- 提取 `JSON` 数据

  ```js
  let responseData = {
      code: 1000,
      data: {},
      message: 'success'
  }
  
  let { code, data = {} } = responseData
  ```
  
- 遍历 Map 结构

  ```js
  let map = new Map()
  map.set('beijing', '北京')
  map.set('xiamen', '厦门')
  
  for (let [key, value] of map) {
      console.log(key, value)
  }
  ```
  
- 输入模块的指定方法和属性

  ```js
  const { readFile, writeFile } = require("fs")
  ```

