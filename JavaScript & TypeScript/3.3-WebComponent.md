---
sidebar_position: 40
---

> Create by **fall** on 17 Oct 2021
> Recently revised in 26 Apr 2023

## Web Component

web 组件系统，使用 JS 原生就可以创建可复用的组件。

和 React、Vue 的组件类似，有特定的功能，比如生命周期，CSS 样式隔离，组合继承。

Web Component 可以创造一个你定制的 HTML 标签，它将会继承 HTML 元素的所有属性，并且可以在任何支持的浏览器中通过引入一个 script，就可以调用这些组件。

Web Component 需要考虑的内容：

- CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM；
- WebComponent 提供了局部封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中；
- template 创建模版，查找模版内容，创建影子 DOM，模版添加到影子 DOM 上；
- shadow DOM 可以隔离全局 CSS 和 DOM，但是 JavaScript 是不会被隔离的；

Custom Element 和 Shadow DOM 都可以让你去创造可复用的组件。

### 使用

创建模板

```html
<template id="span-group" >
  <span>没什么的，对吧？</span>
</template>
```

生成类

```js
class myElement extends HTMLElement {
  // 当元素被创建时，会调用 constrcutor 函数，更多内容请查看生命周期
  constructor() {
    // 必须首先调用 super 方法
    super()
    const dom = document.querySelector('#span-group')
    const content = dom.content.cloneNode(true) // 使用模板的克隆，其他位置引用时不会相互影响
    const text = this.getAttribute('text') // 获取当前组件上的 text 属性
    content.querySelector('span').innerText = text
    this.appendChild(content)
  }
}
// 全局注册类
// 为了避免和 native 的标签冲突，必须用 `-` 进行链接
customElements.define('my-component', myElement) // 分别输入想在 dom 中使用的名称和对应的类
```

使用

```html
<my-component></my-component>
<my-component text="有问题啊"></my-component>
<my-component text="没有问题啊"></my-component>
<my-component></my-component>
```

### 数据监听

```js
class myElement extends HTMLElement{
  // 定义被监视的属性
  static get observedAttributes(){
    return ['foo', 'bar'] // 这些属性都在 标签上被调用
  }
  attributeChangedCallback(attr, oldVal, newVal){
    // 每当将属性添加到 observedAttributes 的数组中时
    switch(attr){
      case 'foo': 
        console.log('foo changed, new value is',newVal)
        break;
      case 'bar':
    }
  }
}
```

给每一个需要被监听的属性添加get函数

```js
get text () {
    return this.getAttribute('text');
}

```

再定义属性的set函数

```js
set text (value) {
    this.setAttribute('text', value);
}

```

现在我们就能直接给组件对象定义属性并赋值，而不需要定义在组件DOM元素上。如下

```js
const mybutton = document.querySelector('my-button');
mybutton.text = 'Hi!';
```

### 生命周期

**生命周期执行顺序**

类进行创建的时候，执行 `constructor`

当元素被插入 DOM 时，会调用 `connectCallback`

从文档中删除时执行 `disconnectedCallback`

当web component被移动到新文档时执行 `adoptedCallback`。

被监听的属性发生变化时执行 `attributeChangedCallback` 



```
constructor -> attributeChangedCallback -> connectedCallback -> disconnectedCallback
```

**生命周期回调**

```js
class myElement extends HTMLElement{
  adoptedCallback(){
    // 当元素通过调用 document.adoptNode(element) 被采用到文档时将会被调用
  }
  static observedAttributes(){ // 被监视的属性
    return ['foo', 'bar'] // 这些属性都在 标签上被调用
  }
  attributeChangedCallback(attr, oldVal, newVal){
    // 每当将属性添加到 observedAttributes 的数组中时
    switch(attr){
      case 'foo': 
        break;
      case 'bar':
    }
  }
  connectCallback(){
    // 当这个元素被插入DOM树的时候将会触发当前方法
    // 对元素进行设置
    // 此时可以确定所有的属性和子元素都已经可用的办法
  }
  disconnectCallback(){
    // 当元素从DOM中被移除的时候，会被调用
  }
}
```

> 理论上通过序列化可以将复杂值传递给属性，但是这样会影响性能，并且你可以直接调用组件的方法，所以不需要这样做。

attributeChangedCallback 要在 connectedCallback 之前执行

因为 web 组件上的属性，被插入DOM前就应该初始化配置了。因此 attributeChangedCallback 要在 connectedCallback 之前执行。 这意味着你需要根据某些属性的值，在 Shadow  DOM 中配置节点，那么你需要在构造函数中引用这些节点，而不是在 connectedCallback 中引用它们。

### 样式

可以将样式书写在 template 中，以保证样式仅应用于 button 上

```html
<template id="mybutton">
  <style>
    button {
      color:blue;
      border: 0;
      border-radius: 5px;
      background-color: brown;
    }
  </style>
  <button id="btn">My Button</button>
</template>
```

### 发送参数

有两种发送方式

- 自定义组件上添加自定义方法监听DOM 元素事件，在需要的地方调用组件的自定义方法
- 使用元素的自定义事件

自定义方法

```js
class MyButton extends HTMLElement{
  constructor(){
    super() // 同 react 都需要在最开始调用 super
    const template = document.getElementById('my_button')
    const content = template.content.cloneNode(true)
    const button = content.querySelector("#btn")
    button.innerText = this.getAttributes('text')
    button.addEventListener('click',ev=>{
      this.onClick('f,m,l') // 把点击事件挂载到该组件上，点击时向外传递参数
      // 因为 HTMLElement 同样继承了 EventTarget，所以也有 dispatchEvent 方法
      // this.dispatchEvent(
      //   new CustomEvent('onClick', {
      //     detail: 'Hello'
      //   })
      // )
    })
  }
}
// 在需要的时候，调用组件的自定义方法
document.querySelector('my-button').onClick = value => {
  console.log(value)
}
```

使用元素的自定义事件

```js
class MyButton extends HTMLElement{
  constructor(){
    super() // 同 react 都需要在最开始调用 super
    const template = document.getElementById('my_button')
    const content = template.content.cloneNode(true)
    const button = content.querySelector("#btn")
    button.innerText = this.getAttributes('text')
    button.addEventListener('click',ev=>{
      this.dispatchEvent(
        new CustomEvent( 'onClick',{
          detail:'hello hu ya'
        })
      )
    })
  }
}
// 在需要的时候，调用组件的自定义方法
document.querySelector('my-button').addEventListener('onClick',(res)=>{
  console.log(res)
})
```

### 插槽

Slot，将内部的内容添加到组件内

```html
<template id="mybutton">
  <style>
    button {
      color:blue;
      border: 0;
      border-radius: 5px;
      background-color: brown;
    }
  </style>
  <button id="btn">My Button</button>
  <p><slot name="my-text">My Default Text</slot></p>
</template>
```

```html
<my-button>
  <p>Another Text from outside</p>
</my-button>
```

### 封装

将组件进行封装，使组件可以直接通过 script 调用

```js
const template = document.createElement('template');
template.innerHTML = `
  <style>
  button {
    width: 60px;
    height: 30px;
    cursor: pointer;
    color: blue;
    border: 0;
    border-radius: 5px;
    background-color: #F0F0F0;
  }
  </style>
  <div>
  <button id="btn">Add</button>
    <p id="message"><slot name="my-text">My Default Text</slot></p>
    <ul id="text-list"></ul>
  </div>
`;
const Texts = [
  'My lady, Hello!',
  'BuiBuiBui',
  'BiliBili',
  'Haiwei is NO.1'
]
class MyButton extends HTMLElement {
  constructor () {
    super()
    const content = template.content.cloneNode(true);
    const button = content.querySelector('#btn');
    const textList = content.querySelector('#text-list');
    this.$button = button;
    this.$message = content.querySelector('#message');
    button.addEventListener('click', (evt) => {
      const li = document.createElement('li');
      li.innerText = Texts[Math.floor(Math.random() * 4)];
      textList.appendChild(li);
      this.dispatchEvent(
        new CustomEvent('onClick', {
          detail: 'Hello fom within the Custom Element'
        })
      )
    })
    this.attachShadow({ mode: 'open' }).appendChild(content);
  }
  get text () {
    return this.getAttribute('text');
  }
  set text (value) {
    this.setAttribute('text', value);
  }
  static get observedAttributes() {
    return ['text'];
  }
  attributeChangedCallback(name, oldVal, newVal) {
    this.render();
  }
  render() {
    this.$message.innerText = this.text;
  }
}

window.customElements.define('my-button', MyButton)
```



### customElements

customElements.prototype.define()

customElements.prototype.get()

customElements.prototype.upgrade()

customElements.prototype.whenDefined()

```js
customElements.whenDefined('my-element')
  .then(() => {
})
```

## 基本使用

把该内容放置在 index.html 的 body 标签内

```html
<template id="span-group">
  <span>没什么的，对吧？</span>
</template>
```

引入该 js 文件

```js
window.onload = function () {
  class myComponent extends HTMLElement {
    constructor() {
      // 必须首先调用 super 方法
      super();
      // 元素的功能代码写在这里
      const template = document.querySelector('#span-group')
      const content = template.content.cloneNode(true) // 为了避免组件之间相互影响，所以
      this.appendChild(content)
    }
  }
  // 最后向 html 中注册组件
  customElements.define('my-component', myComponent);
}
```

使用

```html
<my-component></my-component>
<my-component></my-component>
<my-component></my-component>
<my-component></my-component>
```

## 进阶使用

`MyButton.js`

```js
const template = document.createElement('template');
template.innerHTML = `
  <style>
  button {
    width: 60px;
    height: 30px;
    cursor: pointer;
    color: blue;
    border: 0;
    border-radius: 5px;
    background-color: #F0F0F0;
  }
  </style>
  <div>
  <button id="btn">Add</button>
    <p id="message"><slot name="my-text">My Default Text</slot></p>
    <ul id="text-list"></ul>
  </div>
`;
const Texts = [
  'My lady, Hello!',
  'BuiBuiBui',
  'BiliBili',
  'Haiwei is NO.1'
]
class MyButton extends HTMLElement {
  constructor () {
    super()
    const content = template.content.cloneNode(true);
    const button = content.querySelector('#btn');
    const textList = content.querySelector('#text-list');
    this.$button = button;
    this.$message = content.querySelector('#message');
    button.addEventListener('click', (evt) => {
      const li = document.createElement('li');
      li.innerText = Texts[Math.floor(Math.random() * 4)];
      textList.appendChild(li);
      this.dispatchEvent(
        new CustomEvent('onClick', {
          detail: 'Hello fom within the Custom Element'
        })
      )
    })
    this.attachShadow({ mode: 'open' }).appendChild(content);
  }
  get text () {
    return this.getAttribute('text');
  }
  set text (value) {
    this.setAttribute('text', value);
  }
  static get observedAttributes() {
    return ['text'];
  }
  attributeChangedCallback(name, oldVal, newVal) {
    this.render();
  }
  render() {
    this.$message.innerText = this.text;
  }
}

window.customElements.define('my-button', MyButton)
```

`index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./MyButton.js"></script>
  </head>
  <body>
    <my-button> 
      <p slot="my-text">Another text from outside</p>
    </my-button>
  </body>
  <script>
    const mybutton = document.querySelector('my-button');
    mybutton.addEventListener('onClick', (value) => {
      console.log(value)
      mybutton.text = value.detail
    });
  </script>
</html>
```

## 参考文章

| 作者  | 文章名称                                                     |
| ----- | ------------------------------------------------------------ |
| CodeX | [WebComponent是个什么东西？](https://juejin.cn/post/6956206468316004382) |
|       |                                                              |
|       |                                                              |


