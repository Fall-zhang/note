---
sidebar_position: 10
---

> Create by **fall** on — — 2020
> Recently revised in 12 Jan 2022

## 发展史

1995 年 `JavaScript` 诞生。

ES6 其实是泛指，2015 年六月发布 ES6 第一个版本，然后规定，每年的六月发布一次正式版本，版本号以当年年份为准 ES6。

一般来讲，新增的 JavaScript 的语法通常要经历以下五个阶段

| 阶段      | 英文名        | 含义         |
| --------- | ------------- | ------------ |
| `Stage 0` | `Strawperson` | 展示阶段     |
| `Stage 1` | `Proposal`    | 征求意见阶段 |
| `Stage 2` | `Draft`       | 草案阶段     |
| `Stage 3` | `Candidate`   | 候选阶段     |
| `Stage 4` | `Finished`    | 定案阶段     |

> ES6 改进了前端编程体验，带来更多方便使用的特性，并且适用范围最广，所以本笔记也以 ES6 的内容为基础进行编写。
>
> JavaScript 标准委员会 TC39 提出的实验性功能。在浏览器中的支持是有限的，但是可以通过 Babel 添加语法解析或提供 API 使用此功能。

## 变量

### 变量声明

总共可以声明三种变量

**普通变量**：`var` 

- `var` 声明的作用域是函数作用域，在整个函数内都有效
- 可以被声明多次

**局部变量**：`let` ，只在块级作用域内生效

- 只要遇到大括号都会形成作用域，只在该大括号内可以使用该变量。
- 只能被声明一次

**声明常量**：`const` 

- 用 `const` 声明的变量，只能在声明的时候确定值（或者是指针），后续没有办法修改
- 常量的作用域和 `let` 相同，也是只能声明一次

为什么要引入 let 和 const

- let、const 申明的变量不会被提升。在 javascript 引擎编译后，会保存在词法环境中
- 块级作用域在代码执行时，将 let、const 变量存放在词法环境的一个单独的区域。词法环境内部维护一个小型的栈结构，作用域内部变量压入栈顶。作用域执行完，从栈顶弹出

```js
var foo = ""
let foo1 = ""
const foo2 = ""
```

> 块级作用域有例外，比如 `let` 在 `for` 循环的小括号中使用时，虽然在小括号内，但作用域会被提取到每个大括号中的内容。为了方便编写代码。
>
> `for` 小括号中使用 `var` 变量是可以在循环之后进行访问的，如果在循环中使用的是 `let`，在循环后无法使用。
>
> `let` 不能在变量声明之前访问该变量，`var` 可以访问并且不会报错，但值为 `undefined`
>
> `const` 声明对象或者数组时，只是不能更改指向，可以添加，或者删除对象上的属性。

- 

### 变量类型

在 JS 中，只需声明变量，由引擎判断所属类型，目前为止共有九个类型


- **Data Types**（六个数据类型） ：undefined、Boolean、Number、String、BigInt、Symbol
- **Structural Types** （两个构造类型）：Object、Function、
- **Structural Root** （一个原始数据类型）：null

> 没有 Array 数据类型，本质上 Array 是继承 Object，浏览器做一些优化的对象，所以，如果定义了一个 `arr` 作为数组 `typeof arr` 的值为 `'object'`。

## Number

```js
var num = 233
console.log(typeof num) // 'number'
```

**声明不同进制数据**

二进制（binary）：前缀为 `0b`。

八进制（octonary）：前面添加 `0` 或者是 `0o` （尽量不单独使用 `0` ，会在 `strict` 模式报错）

十六进制（hexadecimal，简写 HEX）：前面添加 `0x` 即可

```js
// 声明一个二进制的数据
var binary = 0b100
// 声明一个八进制的数据
var octal = 0o10
// 十六进制
var hex = 0x10
```

## String

**字符串拼接**

```js
var a = '这是一个字符串'
var b = 'this is a string'
console.log(a + b) // '这是一个字符串this is a string'
console.log(a.concat(b)) // '这是一个字符串this is a string'
```

**字符串特性**

```js
// 跨行声明字符串，需添加'\'进行转译
var str1 = 'hellow \
mybro';
// ES6 中添加新的字符串声明符号，无需添加转译就可直接换行
var str2 = `hellow 
mybro`;
// 新的的字符串拼接方法，以及函数中传入对象
function file({name,age,gender}){
  console.log(`我叫${name}，今年${age}岁，性别${gender}`);
};
file({
  name:'小明',
  gender:'男',
  age:22,
});
// 循环 emoji
let str = '😀🤣😜😍🤗🤔'
for (const emoji of str) {
  console.log(emoji) // 依次输出😀  🤣  😜  😍  🤗  🤔
}
for (let i = 0, l = str.length; i < l; i++) {
  console.log(str[i])  // 不能正确输出表情
}
```

## Object

**面向过程和面向对象**

- 面向过程：只考虑数学逻辑
- 面向对象：将生活逻辑映射到程序中，实现不同的功能功能间相互调用使用
  - 分析有哪些实体
  - 分析设计各个实体的功能
  - 实体间的相互作用

### 创建对象

**对象的拷贝**

- 浅拷贝，拷贝对象的地址，修改对象，会一同修改。
- 深拷贝，拷贝完整的数据，修改对象，只有当前对象会修改。

JavaScript 拷贝对象时，默认是浅拷贝

```javascript
// 三种不同的声明方式
var obj1 = new Object();
var obj2 = Object();
var obj3 = {
  username : "iron-man"
  show:function(){
    console.log(this.username)
  }
}
// 添加属性和方法
obg3.username = "white house"
obj3.show = function(){}
// 不同的输出方式
alert(obg3.username)
alert(obg3[username])
// 删除方法
delete obg3.username 
```

### class

> 详细内容可见 3.3-面相对象编程

**什么是类，什么是对象？**

- **类**：对象特征的集合
- **对象**：具体的某一个事物

```js
// class 是 ES6 中新添加的语法糖，方便定义对象
class Hero{
  heroName
  level
  constructor(heroName,level){ // 可以通过设置默认值(heroName="未知",level="未知")
    this.heroName = heroName
    this.level = level
  }
  callMyName(){
    console.log(`作为一个英雄，我的名字是${this.heroName},我是${this.level}等级`)
  }
}
const bicycle = new Hero('单车骑士',"二级甲等")
bicycle.callMyName()
```

## 数组

> 这里只有大概的知识点，剩余的在独立章节：`-- 扩展存储对象`，中介绍。

数组的基本使用

```js
var arr = [11,54,'啥都没输入']
```

### 常用方法

| 方法              | 作用                                                 |
| ----------------- | ---------------------------------------------------- |
| `array.length`    | 数组的长度                                           |
| `array.concat()`  | 返回连接后的数组                                     |
| `array.join()`    | 用 join 可以在数组后面插入数据，生成一串字符串后返回 |
| `array.indexOf()` | 对元素进行查找，并且返回下标                         |
| `array.slice()`   | 返回数组的一部分                                     |
| `array.sort()`    | 根据字符排序                                         |
| `array.pop()`     | 删除并且返回数组最后一个元素                         |
| `array.push()`    | 从后面给数组添加元素                                 |
| `array.shift()`   | 删除并且返回数组第一个元素                           |
| `array.unshift()` | 在头部插入一个元素                                   |

### 遍历方法

**forEach 循环**

```js
var arr = [11,22,33,44,55];
arr.forEach(function(item){ // 相当于 for(let i = 0;i<arr.length,a++)
  console.log(item)
})
```

**filter 过滤**

```js
var arr = [11,22,33,44,55];
var newarr = arr.filter(function(item){
  return item>20
})
var newarr = arr.filter(item=>item>20)
```

## 集合

> 有关集合的详细内容可查看存储扩展对象文件。

### set

- 键值对相同
- 通过 `add` 方法进行添加
- 所有值不重复

```js
let imgs = new Set()
imgs.add(100)
imgs.add('hello')
imgs.add('hello')
imgs.add(true)
imgs.add(new String('world'))
```

> `WeakSet` 同 Set，但只能是对象的集合，意思就是 `WeakSet` 中的东西是弱引用，如果没有其他的对 `WeakSet` 中对象的引用，这些对象会被垃圾回收掉。

### map

Map 集合的特点

- 通过键值区分不同的 Map
- 通过 `add` 方法进行添加
- `map` 集合传值必须使用键值对进行添加

```js
let map = new Map();
map.set('张三',"吃饭的");
map.set("六六","喝水的");
map.set("六六","吃药了");
console.log(map);
// Map对象取值
console.log(map.get('六六')); // 吃药了
```

> `WeakMap`  同 Set，意思就是 `WeakMap` 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题

## 数组、对象、集合的遍历

### 数组的遍历

```js
var arr = [10,22,33,44,55,66];
//1. for 循环
for(var i = 0;i<arr.length;i++){
  document.write('for循环'+i+','+arr[i])
}
//2. for in 此时 i 指的是 index
for(var i in arr){
  document.write('for in 循环'+ i+','+ arr[i])
}
//3. forEach
arr.forEach((item,index,arr)=>{
  document.write('forEach'+index+','+item)
})
// 4. for...of
for(item of arr){
  document.write("for...of"+item +"<br>")
}
```

### 对象的遍历

对象只能使用 `for..in` 报错

```js
// for in
var person = {
  username :'iron man',
  age:28,
  gender:"male"
}
for(var attr in person){
  document.write("对象的遍历:"+attr+'分隔'+person[attr]+"<br>")
}
```

### 集合的遍历

map 集合的遍历

集合使用 for...in 不会出任何结果

```js
var map = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
// 对map进行循环
for (let item of map) {
    console.log(item[0],item[1])
}
// 将item解构
for(let [key,value] of map){
    console.log(key,value)
}
```

set 的遍历

```js
var mySet = new Set(['闪电','flash','too'])
console.log(mySet)
mySet.forEach(item => {
  console.log(item)
})
mySet.forEach(function(item){
  console.log(item)
})
// 以键值对的方式进行循环
for (let item of mySet.entries()) {
  console.log(item)
} 
// 以键的方式进行循环
for (let item of mySet.keys()) {
  console.log(item)
}
```

## 严格模式

严格模式是对语法进行额外限制，使代码更明确。

`use strict` 是一种运行时自动执行更严格的 `JavaScript` 代码解析和错误处理的方法。如果代码错误被忽略或失败，将会产生错误或抛出异常。

非严格模式下

```js
a = 100
console.log(a) // 100
```

严格模式下

```js
"use strict"
a = 100
console.log(a) // 我直接给你报错！Error! 
```

> ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 "use strict"

**严格模式主要有以下限制：**

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用 with 语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀 0 表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量delete prop ，会报错，只能删除属性 selete global[prop]
- eval 不会在它的外层作用域引入变量
- eval和arguments不能被重新赋值
- arguments不会自动反映函数参数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象，此 this 指向 undefined，能避免在顶层使用 this，和顶层使用 this 报错。
- 不能使用fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字（比如protected、static和interface）

严格模式是ES5引入的，上面这些限制，模块都必须遵守。

严格模式的好处：

- 使调试跟更容易。如果代码错误本来会被忽略或失败，那么现在将会产生错误或抛出异常，从而更快地发现代码中的问题，并更快地指引它们的源代码。

- 防止意外全局。如果没有严格模式，将指赋值给未声明的变量会自动创建一个具有该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，会直接报错。

- 消除隐藏威胁。在没有严格模式的情况下，对null或undefined的这个值得引用会自动强制到全局。这可能会导致需要headfakes和pull-out-your-hair类型的错误。在严格模式下，因公用null或undefined的这个值会引发错误。

- 不允许重复的参数值。严格模式在检测到函数的重复命名参数（例如，函数foo（var1，var2，var1）{}）时会引发错误，从而捕获代码中几乎可以肯定存在的错误，否则会浪费大量的时间追踪命名上的问题。

  > 注意：它曾经是（ECMAScript 5 中）strict模式将禁止重复的属性名称（例如：`var object = {foo：“bar”，foo：“baz”}`；）但是从ECMAScript 2015 开始，就不再有这种情况了。 

- 使 `eval()` 更安全。eval（）在严格模式和非严格模式下的行为方式有些不同。最重要的是，在严格模式下，在eval（）语句内部声明的变量和函数不会再包含范围中创建（它们是以非严格模式在包含范围中创建的，这也可能是问的常见来源）。

- 抛出无效的使用错误的删除符。删除操作符（用于从对象中删除属性）不能用于对象的不可配置属性，当试图删除一个不可配置的属性时，非严格代码将自动失败，而在这种情况下，严格模式会引发错误

## 参考文章：

| 文章标题                  | 地址                                                       |
| ------------------------- | ---------------------------------------------------------- |
| "use strict" 的意义和好处 | https://blog.csdn.net/qq_36379070/article/details/82586892 |

