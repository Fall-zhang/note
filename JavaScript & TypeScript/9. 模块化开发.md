浏览器传统加载模式

```html
<!-- 同步加载 -->
<script src = "test.js"></script>
<!-- 异步加载，顺序执行，文档解析完成后执行 -->
<script src="test.js" defer></script>
<!-- 乱序加载，只要下载完就执行--> 
<script src="test.js" async></script>
```

浏览器`<script>`标签中设置 `type = "module"` 将默认按照 defer 进行加载

```js
// ES6的模块依赖于 import export 两个命令，并且自动采用严格模式
<script type="module" src="test.js"></script>
```

倒出和导入

导出

```js
// person.js
// 写法一：单独导出
export const name = '布兰'
export const age = 12
// 写法二：按需导出
const name = '布兰', age = 12
export { name, age }
// 写法三：重命名后导出
const name = '布兰', age = 12
export { name as name1, age as age1 }
// 写法四：默认导出
const name = '布兰'
export default name
```

导入

```js
// 按需导入
import { name, age } './person.js'

// 导入后重命名
import { name1 as name, age1 as age } from './person.js'

// 默认导入
import person from './person.js'

// 整体导入
import * as person from './person.js'

// 混合导入
import _, { each } from 'lodash'
```

- 导入的变量名必须与导出模块的名字一致，可以使用 `as` 进行重命名；
- 导入的变量都是只读的，不能改写；
- `import` 命令具有提升效果，会提升到整个模块的头部，首先执行；
- `import` 是编译时导入，所以不能将其写到代码块（比如 `if` 判断块里）或者函数内部；
- `import` 会执行所加载的模块的代码，如果重复导入同一个模块则只会执行一次模块；

`import` 和 `export` 的复合写法：`export` 和 `import` 语句可以结合在一起写成一行，相当于是在当前模块直接转发外部模块的接口，复合写法也支持用 `as` 重命名。以下例子中需要在 `hub.js` 模块中转发 `person.js` 的接口：

```js
// person.js
const name = '布兰', age = 12
export { name, age }
// 按需转发接口（中转模块：hub.js）
export { name, age } from './person.js'
// 相当于
import { name, age } from './person.js'
export { name, age }

// person.js
const name = '布兰', age = 12
export default { name, age }
// 转发默认接口（中转模块：hub.js）
export { default } from './person.js'
// 相当于
import person from './person.js'
export default person
```

`ES6` 模块和 `CommonJS` 模块的差异：

- `CommonJS` 模块输出的是一个值的拷贝（一旦输出一个值，模块内部的变化就影响不到这个值），`ES6` 模块输出的是值的引用（是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值）；
- `CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口；
- `CommonJS` 模块的 `require()` 是同步加载模块，`ES6` 模块的 `import` 命令是异步加载，有一个独立的模块依赖的解析阶段；