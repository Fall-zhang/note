> Create by **fall** on 2022-03-17
> Recently revised in 2022-03-17

## Proxy

代理，用来定义基本操作的自定义行为，对被代理对象 `target` 操作之前会先进行拦截。

- 实质上是目标对象`target`的包装
- 可以通过代理对象进行操作，也可以直接对 `target` 进行操作，两者相互独立存在，进行操作
- 只有通过 proxy操作时，才会被预设的方法拦截。直接操作对象，不会受到任何拦截影响。

```js
// 创建代理对象，代理对象内有两个对象，一个是 target，表示被监听对象，另一个是 handler，表示做如何处理
let proxy = new Proxy(target,handler)
// 代理对象的使用
let instance = new Proxy({user:'fall'},{
  get(target,propKey,receiver){
    return `你好啊，${target.name}`
  }
})
// 在对被代理对象操作时，能进行拦截，并且获取的是代理处理后的返回值
instance.name // '你好啊，fall'
```

如果 `handler` 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上（对代理赋值，直接作用于 target）

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.name = '布兰'
target.name  // '布兰'
```

### 方法

`Proxy` 对象上的方法一共有一下好多个

- `get` 用于拦截属性的读取操作
- `set` 用于拦截对象的属性操作
- `has` 拦截 `propKey in proxy` 的操作，表示属性是否存在。
- `deleteProperty ` 拦截 `delete` 操作
- `ownKeys` 拦截 `Object.keys()` `for...in` 等循环
- `getOwnPropertyDescriptor` 获取对象上属性的描述对象时的代理
- `defineProperty` 命名对向上的属性描述时的代理
- `preventExtensions` 设置防止扩展属性是的代理
- `getPrototypeOf` 获取
- `isExtensible` 可否扩展的
- `setPrototypeOf`
- `apply`
- `construct`

```js
let target={
  name:'fall'
}
let proxy = new Proxy(target, {
  get(target,propKey,receiver){},
  // 拦截对象属性的读取，target 指的是被代理的对象，propKey 指受到操作的对象，receiver 表示该 Proxy 代理对象
  set(target,propKey,value,receiver){},
  // 拦截对于对象中属性值的设置，target 指的是被代理的对象，propKey 指受到操作的对象，value表示属性对应的值，receiver 表示该 Proxy 代理对象
  has(target,propKey){},
  // 拦截 propKey in proxy 操作，返回一个布尔值
  deleteProperty(target,propKey){},
  // 拦截删除 propKey 的操作
  ownKeys(target){},
  // 拦截多个Object操作，返回一个数组，数组包括所有值，不同于Object.keys()，可以返回Symbol对象
})
```

### 静态方法

`Proxy.revocable()` 定义一个可撤销的 Proxy

```js
let target = {}
let handler = {}
let {proxy, revoke} = Proxy.revocable(target, handler)

proxy.foo = 123
proxy.foo  // 123
revoke() // 执行结构的第二个方法，就可以撤销该 proxy
proxy.foo  // TypeError
```

### 示例

get 示例 

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般不用添加这个参数）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return 'nothing' // 如果想要使用默认获取值的操作，使用该返回值
  },
})
console.log(proxyStaff.age)
// 如果获取本身不存在的值，则返回 undefined
// 如果定义了 return 'nothing'，那么
proxyStaff.career // 'nothing'
```

set 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  set(target,propKey,value,receiver){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    console.log(receiver)// 指向代理对象，此处指向 proxyStaff
    target[propKey] = value
    // 该关键字不需要 return ，在这里无意义  
  }
})
proxyStaff.age = 23
```

has 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  has(target,propKey){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    return propKey in target 
  }
})
if('age' in proxyStaff){
  console.log(proxyStaff.age)
}
```

deleteProperty 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  deleteProperty(target,propKey){
    return delete proxyStaff.age // 此处只能返回 true & false，表示删除是否成功
  }
})
if('age' in proxyStaff){
  delete proxyStaff.age 
  console.log(proxyStaff)
}
```

ownKeys 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  ownKeys(target){
    return Object.keys(target) 
    // 用于拦截 Object.getOwnPropertyNames()、Object.keys()、Object.getOwnPropertySymbols()、for...in 等循环类操作
  }
})
console.log(Object.keys(proxyStaff))
```

`getOwnPropertyDescriptor` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  getOwnPropertyDescriptor(target,propKey){
    return Object.getOwnPropertyDescriptor(target,propKey) 
    // 用于拦截 Object.getOwnPropertyDescriptor()
  }
})
console.log(Object.getOwnPropertyDescriptor(proxyStaff,'name'))
```

`defineProperty` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  defineProperty(target,propKey,propKeyDesc){
    return Object.defineProperty(target,propKey,propKeyDesc) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
console.log(Object.defineProperty(proxyStaff,'hobby',{value:'beauty'}))
```

`preventExtension` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  preventExtensions(target){
    return Object.preventExtensions(target) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
Object.preventExtensions(proxyStaff)
proxyStaff.age = 23
console.log(proxyStaff.age) // undefined
```

`getPrototypeOf` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  getPrototypeOf(target){
    return Object.getPrototypeOf(target) 
  }
})
console.log(Object.getPrototypeOf(proxyStaff)) 
```

`isExtensible` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  isExtensible(target){
    return Object.isExtensible(target)// 返回一个布尔值，表示是否可以扩展
    // return false  // 直接返回 false 会报错
  }
})
console.log(Object.isExtensible(proxyStaff)) 
```

`setPrototypeOf` 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  setPrototypeOf(target,proto){
    // 设置原型方法会调用该函数
    console.log(`向${target}的上，设置了${proto}原型`);
    return Object.setPrototypeOf(target,proto) 
  }
})
console.log(Object.setPrototypeOf(proxyStaff,{}))
```

apply 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function app(x,y){return x+y}
const proxyStaff = new Proxy(app,{
  apply(target,object,args){
    // object 是 this 参数的指向
    // args 是参数列表
    console.log('调用了该app方法') 
    return app.call(object,...args) 
  }
})
console.log(app(5,6))
```

construct 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function App(x,y){return x+y}
const proxyStaff = new Proxy(App,{
  construct(target,args){
    console.log(args[0]);
    return new App(...args)
  }
})
console.log(new proxyStaff(42,12))
```

## Reflect

> 现在是一个坑

和 Proxy 相同，Reflect 作用是恢复到原来的默认值操作

- `Reflect` 是一个内置的对象，它提供拦截 `JavaScript` 操作的方法。这些方法与 `proxy handlers` 的方法相同。`Reflect` 不是一个函数对象，因此它是不可构造的。
- 设计的目的：
  - 将 `Object` 属于语言内部的方法放到 `Reflect` 上；
  - 修改某些 `Object` 方法的返回结果，让其变得更合理；
  - 让 `Object` 操作变成函数行为
  - `Proxy handles` 与 `Reflect` 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 

### 静态方法

- `Reflect.apply(target, thisArgument, argumentsList)` 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 `Function.prototype.apply()` 功能类似；
- `Reflect.construct(target, argumentsList[, newTarget])` 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`；
- `Reflect.defineProperty(target, propertyKey, attributes)` 和 `Object.defineProperty()` 类似。如果设置成功就会返回 `true`；
- `Reflect.deleteProperty(target, propertyKey)` 作为函数的 `delete` 操作符，相当于执行 `delete target[name]`；
- `Reflect.get(target, propertyKey[, receiver])` 获取对象身上某个属性的值，类似于 `target[name]`；
- `Reflect.getOwnPropertyDescriptor(target, propertyKey)` 类似于 `Object.getOwnPropertyDescriptor()`。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 `undefined`；
- `Reflect.getPrototypeOf(target)` 类似于 `Object.getPrototypeOf()`；
- `Reflect.has(target, propertyKey)` 判断一个对象是否存在某个属性，和 `in` 运算符 的功能完全相同；
- `Reflect.isExtensible(target)` 类似于 `Object.isExtensible()`；
- `Reflect.ownKeys(target)` 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 `Object.keys()`, 但不会受 `enumerable` 影响)；
- `Reflect.preventExtensions(target)` 类似于 `Object.preventExtensions()`。返回一个 `Boolean`；
- `Reflect.set(target, propertyKey, value[, receiver])` 将值分配给属性的函数。返回一个 `Boolean`，如果更新成功，则返回 `true`；
- `Reflect.setPrototypeOf(target, prototype)` 设置对象原型的函数. 返回一个 `Boolean`， 如果更新成功，则返回 `true`；

Proxy和Reflect是成对出现的，所以合起来就有一个示例

### 示例

```js
// 这段代码中有地方完蛋了，应该是reflect是用错了，看看错在哪了
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般就不用添加这个参数了）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return Reflect.get(target, propKey) // 如果想要使用默认获取值的操作，使用该返回值
  },
  set(target,propKey,value){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    // target[propKey] = receiver //在此处意为：将staff.age 设置为 23 
    return Reflect.set(target,propKey,value) // 如果想要使用默认获取值的操作，使用该返回值
  },
  deleteProperty(target,propKey){
    console.log(target) 			// target 指向的是 staff 
    console.log(propKey)			// propKey 指向的是 key age
    return Reflect.deleteProperty(target,propKey) // 如果想要使用默认获取值的操作，使用该返回值
  } 
})

delete proxyStaff.age
proxyStaff.age= 23
console.log(proxyStaff.age);
```

