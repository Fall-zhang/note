> Create by **fall** on 2021年11月14日11:38:41
> Recently revised in 2021年11月11日11:25:00

## 函数类型

函数类型的声明

```typescript
function sum(x:number,y:number):number{
  return x+y
}
let sum2:(x:number,y:number)=>number=funciton(x:)
```

用接口定义函数类型

```typescript
interface SumFun {
	(num1:number,num2:number):number
}
```

### **可选参数**

```ts
function fullName(firstName:string, lastName?:string){
  let result = firstName
  if(lastName){
    result  += ` ${lastName}`
  }
  return result
}
```

最后一个可选参数之后，不能出现必填参数

### **参数的默认值**

```ts
function fullName(firstName:string ,secondName:string = '林枫'){
  return firstName + ' '+ secondName
}
```

### **剩余参数**

```ts
function createArr(a:number,...items:number[]){
  let result:number[] = []
  items.forEach(item=>{
    result.push(item)
  })
  return result
}
const arr = createArr(888,666,999,1314)
console.log(arr)
```

### **函数重载**

函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。

比如说，以下方法，使用时会出现问题

```ts
// result.split 会报错，表明类型 number上不能使用 split
type Combinable = string | number;
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
   return a.toString() + b.toString();
  }
  return a + b;
}
const result = add('Semlinker', ' Kakuqo');
result.split(' ');
```

可以使用函数重载去解决这个问题

```js
type Combinable = string | number;
function add(x:number,y:number) 
function add(x:string,y:string) 
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
   return a.toString() + b.toString();
  }
  return a + b;
}
const result = add('Semlinker', ' Kakuqo');
result.split(' ');
```

