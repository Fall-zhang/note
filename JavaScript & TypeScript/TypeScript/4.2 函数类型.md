> Create by **fall** on 2021-11-14
> Recently revised in 2021-11-25

## 函数类型

函数类型的声明

```typescript
function sum(x:number,y:number):number{
  return x+y
}
let sum2:(x:number,y:number)=>number=funciton(x:)
```

用接口定义函数类型

```typescript
interface SumFun {
	(num1:number,num2:number):number
}
// 使用函数类型
const add:SumFun = function(a,b){
  return a + b
}
add(12,23)
```

### **可选参数**

```ts
function fullName(firstName:string, lastName?:string){
  let result = firstName
  if(lastName){
    result  += ` ${lastName}`
  }
  return result
}
```

最后一个可选参数之后，不能出现必填参数

### **参数的默认值**

```ts
function fullName(firstName:string ,secondName:string = '林枫'){
  return firstName + ' '+ secondName
}
```

### **剩余参数**

```ts
function createArr(a:number,...items:number[]){
  let result:number[] = []
  items.forEach(item=>{
    result.push(item)
  })
  return result
}
const arr = createArr(888,666,999,1314)
console.log(arr)
```

### **函数重载**

函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。 要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。

比如说，以下方法，使用时会出现问题

```ts
// result.split 会报错，表明类型 number上不能使用 split
type Combinable = string | number;
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
   return a.toString() + b.toString();
  }
  return a + b;
}
const result = add('Semlinker', ' Kakuqo');
result.split(' ');
```

可以使用函数重载去解决这个问题

```js
type Combinable = string | number;
function add(x:number,y:number) 
function add(x:string,y:string) 
function add(a: Combinable, b: Combinable) {
  if (typeof a === 'string' || typeof b === 'string') {
   return a.toString() + b.toString();
  }
  return a + b;
}
const result = add('Semlinker', ' Kakuqo');
result.split(' ');
```

## 函数

### 函数的基本使用方法

```ts
// js的函数书写方法
function add(x, y) {
  return x + y
}
let sum = function (x, y) {
  return x + y
}
let plus = (x: string, y) => {
  return x + y
}
// ts 的函数的书写方法
let keke = (y: string): string => {
  console.log('咳咳' + y)
  return ''
}
keke('fake')
```

### 可选参数 默认参数 和剩余参数

```ts
function create(x:number = 22,y?:string):number{
  console.log(y)
  return x +3
}
console.log(create())
// 剩余参数存放在 ... 后面即可捕获剩余参数
function mountain(num:number,...arr:string[]){
    console.log('这是第'+num+"次输出")
    console.log(arr[0])
  }
  mountain(12,"阿尔卑斯",'珠穆朗玛','嵩山',"华山")
```

### 函数的泛型

泛型意思是，可以等到需要传入值的时候，这时候再限定参数将所需要的类型传入，达到限制类型的目的

```ts
function anyType<C>(x:C,y:number):C[]{
  let arr = []
  for(let i =0 ;i<y;i++){
    arr.push(x)
    console.log('hite me')
  }
  return arr
}
console.log(anyType<number>(12,13))
```

