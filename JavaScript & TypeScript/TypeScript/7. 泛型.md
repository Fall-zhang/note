## 泛型

最初学习的泛型

```ts
function random<T>(arg:T):T{
  return arg
}
// 首先是 <T> 在调用函数时使用，T 将会被传入的类型取代。
random<string>('22')
random<number>(333)
// 就像传入参数一样，传入类型，然后调用类型
```

一般来讲会有几个约定俗成的名称

- `K`：顾名思义，对象中的键
- `V`：顾名思义，对象中的值
- `T`：一本的类型 Type
- `E`：元素类型 Element

可以进行省略类型的填写

```ts
funtion random<T,U>(key:T,value:U){
  console.log(key)
  return value
}
random(13,'哇塞')
```

### 类型约束

如果想打印一些属性，如果完全不进行约束就会报错，

```ts
function trace<T>(arg: T): T {
  console.log(arg.size); // Error
  return arg;
}
// 可以通过接口去限制该属性
interface Opti{
  size:number
}
// 继承该接口之后就不会出现问题
function trac2<T extends Opti>(arg:number):T{
  console.log(arg)
  return arg
}
// 当然，传入参数时也要传入实现该接口的参数。
```

### 泛型工具类型

#### `typeof`

主要作用是去获取变量或者是属性的类型

```ts
interface Person{
  name:string;
  age:number
}
const sai:Person = {name:'琦玉',age:23}
type Sai = typeof sai // 此时 type Sai == Person
// 也就可以使用 Sai
const bald:Sai = {name:'秃头披风',age:28}
```

甚至是函数类型

```ts
function toArr(x:number):Array<number>{
  return [x]
}
type Rebuild = typeof toArray // (x:number)=>number[]
```

#### `keyof`

TypeScript 2.1 版本引入的，可以获取某种类型的所有件，返回类型是联合类型。

```ts
interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
type K2 = keyof Person[]; // "length" | "toString" | "pop" | "push" | "concat" | "join" 
type K3 = keyof { [x: string]: Person };  // string | number
```

数字索引，字符串索引







