> 创建时间：2021-05-26
> 更新时间：2021-09-25

## JS中的对象

对象分为三种

- 本地对象 ( native object )：Boolean、String、Number、Object、Array、Function、Error、Date、RegExp
- 内置对象（ built-in object ）：Global、Math、JSON
- 宿主对象：BOM、DOM

## Math对象上的方法

| 方法             | 作用                                                        |
| ---------------- | ----------------------------------------------------------- |
| `Math.abs()`     | 返回取绝对值                                                |
| `Math.max()`     | 传入逗号分割的多个数，返回最大的参数                        |
| `Math.min()`     | 传入逗号分割的多个数，返回最小的参数                        |
| `Math.round()`   | 四舍五入到最接近的整数                                      |
| `Math.ceil()`    | 返回向上取整的值                                            |
| `Math.floor()`   | 返回向下取整的值                                            |
| `Math.random()`  | 返回值为随机数，无需传入值                                  |
| `Math.E`         | 常数 e≈2.71828                                              |
| `Math.trunc()`   | 返回该数值的整数部分                                        |
| `Math.sign()`    | 返回数值的类型，1 表示正数，-1 表示负数，0                  |
| `Math.cbrt()`    | 返回数值立方根                                              |
| `Math.clz32()`   | 返回数值的 32 位无符号整数形式，即32-该数值的二进制表示位数 |
| `Math.imul(a,b)` | 返回两个数相乘                                              |
| `Math.fround()`  | 返回数值的 32 位单精度浮点数形式                            |
| `Math.pow(x,y)`  | 求 x 的 y 次方                                              |

- `Math.hypot()`  返回所有数值平方和的平方根 `Math.hypot(4,4,4,4) == 8`    
- `Math.expm1()`：  返回`e^n - 1`
- `Math.log1p()`：返回 1 + n 的自然对数(`Math.log(1 + n)`)
- `Math.log10()`：返回以 10 为底的 n 的对数
- `Math.log2()`：返回以 2 为底的n的对数
- `Math.sinh()`：返回 n 的双曲正弦
- `Math.cosh()`：返回 n 的双曲余弦
- `Math.tanh()`：返回 n 的双曲正切
- `Math.asinh()`：返回 n 的反双曲正弦
- `Math.acosh()`：返回 n 的反双曲余弦
- `Math.atanh()`：返回 n 的反双曲正切

## RegExp

### 对象特性

```js
// 正则表达式的声明
const reg1 = new RegExp('hello','ig') 
const reg2 = new RegExp(/xYz\d+/gi, i) // 如果传入了第二个参数，以第二个为准
const reg3 = RegExp('hello','ig')
const reg4 = /hello/gi
// i 表示不区分大小写，g 表示可以同时选取多个，m 表示可以换行匹配，每一行的内容独立 
reg.flags // 可以返回当前正则的所有修饰符
```

**修饰符** 

- `u` 处理大于 `\uFFFF `的 `Unicode` 字符
- `i` 表示不区分大小写
- `g` 表示可以同时选取多个
- `m` 表示可以换行匹配，每一行的内容独立
- `y` 同样是全局匹配，只不过匹配必须连在一起
- `s` dotAll，只要有点，可以用`.`代替所有字符

`u` 修饰符：含义为 `Unicode` 模式，用来正确处理大于 `\uFFFF` 的 `Unicode` 字符。也就是说，如果待匹配的字符串中可能包含有大于 `\uFFFF` 的字符，就必须加上 `u` 修饰符，才能正确处理。

```js
// 加上 u 修饰符才能让 . 字符正确识别大于 \uFFFF 的字符
/^.$/.test('🤣')   // false
/^.$/u.test('🤣')  // true

// 大括号 Unicode 字符表示法必须加上 u 修饰符
/\u{61}/.test('a')   // false
/\u{61}/u.test('a')  // true

// 有 u 修饰符，量词才能正确匹配大于 \uFFFF 的字符 
/🤣{2}/.test('🤣🤣')  // false
/🤣{2}/u.test('🤣🤣') // true
```

`RegExp.prototype.unicode` 属性表示正则是否设置了 `u` 修饰符：

```js
/🤣/.unicode   // false
/🤣/u.unicode  // true
```

`y` 修饰符，与 `g` 修饰符类似也是全局匹配；不同的是 `g` 是剩余字符中匹配即可，而 `y` 则是必须在剩余的第一个字符开始匹配才行，所以 `y` 修饰符也叫黏连修饰符：

```js
let s = 'aaa_aa_a'
let r1 = /a+/g
let r2 = /a+/y

r1.exec(s)  // ["aaa"]
r2.exec(s)  // ["aaa"]

r1.exec(s)  // ["aa"]
r2.exec(s)  // null
```

`RegExp.prototype.sticky` 属性表示是否设置了 `y` 修饰符：

```js
/abc/y.sticky  // true
```

`s` 修饰符，开启 dotAll 模式，ES2018引入，通过 `.` 表示任意字符

```js
/fall.again/.test('fall\nagain') // false
/fall.again/s.test('fall\nagain') // true
```

具名匹配，可以将捕获的字符串进行命名，通过命名进行快速查找

没有使用具名匹配

```js
let day = /(\d{4})-(\d{2})-(\d{2})/
let result = day.exec('2021-08-12')
// result[0] === '2021-08-12'
// result[1] === '2021'
// result[2] === '08'
// result[3] === '12'
```

使用具名匹配

```js
let day = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
let result = day.exec('2021-08-12')
// result.groups { year: "2021", month: "08", day: "12" }'
```

配合结构赋值

```js
let {groups: {year, month, day}} = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.exec('2021-08-12')
console.log(year, month, day)  // 2021 08 12
```

后行断言 `(?<=y)x`，`x` 只有在 `y` 后面才能匹配：

```js
/(?<=\$)\d+/.exec('I have $100.')  // ['100']
// 否定断言： (?<!y)x，x 只有不在 y 后面才能匹配：

/(?<!\$)\d+/.exec('I have $100.')  // ['00']
```

### 实例方法

- `reg.test()` 测试是否符合，返回`true` 或者 `false`
- `reg.dotAll()` 检测该正则是否处在 dotAll 模式
- `reg.exec()` 返回符合的字符串组成的数组。

## BigInt

可以表示大于 `2^53-1` 以上的整数。BigInt可以表示任意大的数字

```js
const num1 = 23n
const num2 = BigInt(66)
```

其他特性

```js
10n == 10 // true
10n === 10 //false
10n > 8 // true
10 + Number(25n) // 35
10 + 20n // TypeError
100n + BigInt(55) // 155n
```

## Array

为内存中多个连续的值存储多个数据的存储控件

### 扩展运算符

数据扩展运算符 `...` 可以展开数组

```js
// 应用一：函数传参
Math.max(...[1, 2, 3])  // 3
// 应用二：数组合并
let merge = [...[1, 2], ...[3, 4], 5, 6]  // 1, 2, 3, 4, 5, 6
// 应用三：浅克隆
let a = [1, 2, 3]
let clone = [...a]
a === clone  // false
// 应用四：数组解构
const [x, ...y] = [1, 2, 3]
x  // 1
y  // [2, 3]
```

如果数组上没有值，ES6 新增语法就会将空位默认替换为 undefined

```js
[...[1, , 3].values()]  // [1, undefined, 3]
```

### 静态方法

`Array.from()` 可以将字符串，类数组对象（ `NodeList`，`arguments`），Set 和可迭代对象转化为数组

```js
// 字符串转数组
Array.from("我搜搜") //  [ "我", "搜", "搜" ]
// 数组合并，去重
let merge = [...[1,2,3],...[1,5,3]]
Array.from(new Set(merge))
function fun(){// 无论传入多少个数据，都可以拼接为数组，然后返回
  return Array.from(arguments) 
}
fun(1,5,6)
// 除此之外，第二个参数可以将每一个数据都进行一次操作
Array.from("我搜搜",x=>x+"_") // ["我_", "搜_", "搜_"]
Array.from({length: 3}, (v, i) => ++i)  // [1, 2, 3] 
```



`Array.of()` 可以将参数转换为数组

`Array.of(1,2,3)` 转换后为 `[1,2,3]` 

**********

### 实例方法

**单个添加删除**

- `Array.prototype.push()` 从末尾进行添加
- `Array.prototype.pop()` 从末尾取出
- `Array.prototype.shift()` 从最开始取出
- `Array.prototype.unshift()` 从最开始插入
- `Array.prototype.concat()` 合并两个数组

```js
// 示例将在下一次更新中补充
```

**从数组中取出数组**

`Array.prototype.splice(start,num,in)`

- start 开始的项
- num 有几项。为零，表示不截取
- in 插入的内容

```js
// 示例将会在后面补充
// 删除
// 插入
// 替换
```

`Array.prototype.slice(start,end)` 

- start 截取的开始位置（可以为负数，表示从后向前，第几位）
- end 截取的结束位置

```js
// 示例将会在后面补充
```

**方法**

- `Array.prototype.map` 映射
- `Array.prototype.filter` 返回值为true的所有成员
- `Array.prototype.reduce` 减少
- `Array.prototype.every` 每一项都返回 true，则返回 true
- `Array.prototype.some` 任意一项为 ture 返回 true
- `Array.prototype.forEach` 无返回值 

```js
let arr = [5,6,4,6,2]
let arr1 = arr.map(item=>item+2) //[ 7, 8, 6, 8, 4 ]
// 对每一个进行操作
let arr2 = arr.filter(item=>item>5) // [ 6, 6 ]
// 返回符合条件的数值
let arr3 = arr.reduce((item1,item2)=>item1+item2) // 23
// 合并为一个数值，item1 是操作后
```

查找下标

`Array.prototype.indexOf(content,index)` 从开始进行查找

`Array.prototype.lastIndexOf()` 从结束位置开始查找

- content 查找的内容
- index 开始的查找点

```js
// 示例待添加
```



**数组的覆盖**

`Array.prototype.copyWithin(i,j,k)` 

- i 必填：从数组的哪个下标开始替换，为负数，从后向前数
- j 可填：开始填充的位置，默认为 0
- k 可填：结束填充的位置，默认为原数组长度

使用当前数组，从组数的第 i 位，开始进行替换(还是举例子更形象一点)

```js
[1,2,3,4,5].copyWithin(2) // [1,2,1,2,3]
[1,2,3,4,5].copyWithin(-2) // [1,2,3,1,2]
[1,2,3,4,5].copyWithin(2,1) // [1,2,2,3,4]
[1,2,3,4,5].copyWithin(2,1,2) // [1,2,2,4,5]
```

**数组的查找**

`Array.prototype.find()` 

```js
[1, 6, 9].find((val, index, arr) => val % 2 === 0) // 返回 val
[1, 6, 9].findIndex((val, index, arr) => val % 2 === 0) // 返回 index
```

`Array.prototype.fill()`  数组中的覆盖

```js
[1,2,3,4,5].fill('2',1,3) 
// 第一个参数，表示传入的字符串
// 第二个参数选填：开始的索引
// 第三个参数选填：结束的索引
```

`Array.prototype.keys()` `Array.prototype.values()` `Array.prototype.entries()`

 ```js
var cc = ["1","2","6","66"]
for(i of cc.keys()){
  console.log(i); // 1,2,3,4
}
for(i of cc.values()){
  console.log(i); // "1","2","6","66"
}
for(i of cc.entries()){
  console.log(i); // [ 0, "1" ] [ 1, "2" ] [ 2, "6" ] [ 3, "66" ]
}
 ```

`Array.prototype.includes()` 是否包含

```js
// 想要查看数组中是否包含 某个元素 x，
// 原来的做法
if([].indexOf(x)>-1){}
if(~[].indexOf(x)){}
// 现在的做法
if(Array.includes(x))
```

并且可以检验数组中是否包含 `NaN`，indexOf使用的是 `===` 全等，无法在遇到 `NaN` 时返回 index

```js
[1, NaN, 3].indexOf(NaN)   // -1
[1, NaN, 3].includes(NaN)  // true
```

**把数组拍平**

`Array.prototype.flat()`

把二维数组，或者是数组中嵌套数组的内容拍平

```js
[1,2,[3,4,[5]]].flat() // [ 1, 2, 3, 4, [5] ]
// 通过 Infinity 可以直接全部展开为一维数组
[1,2,[3,4,[5]]].flat(Infinity) //[ 1, 2, 3, 4, 5 ]
```

**数组排序**

`Array.prototype.reverse() ` 数组倒序

`Array.prototype.sort()` 数组排序

**数组转换**

`Array.prototype.toString()` 转换为字符串返回

`Array.prototype.toLocaleString()` 转换为本地格式字符串返回

`Array.prototype.join()` 用指定的字符分割数组，并转换为字符串



## JSON

`JSON.stringify` 

基本用法：`JSON.stringify(value[, replacer [, space]])`

第三个参数一般没什么用，作用是指定 space 个空格的缩进而已，想让代码更好看一点，就写上多少个空格的缩进。

`0xD800` 到 `0xDFFF` 之间的码点不能单独使用，所以 `JSON.stringify()` 对单个码点进行操作，如果符合`UTF-8`标准，会返回对应的字符，如果不满足会返回对应的码点。

```js
let replacerFun = function (key, value) {
  console.log(key, value)
  if (key === 'name') { // 如果key 等于 name<直接返回 undefined
    return undefined // 返回 undefined 时，该键值对直接忽略，
  }
  return value
}
let myIntro = {
  name: 'fall',
  age: 25,
  like: 'FE'
}
JSON.stringify(myIntro, replacerFun) // {"age":25,"like":"FE"}
```

**实现对象的深拷贝**

```js
let info = {
  name:'fall'
  age: 25,
  like: 'FE'
}
function deepClone() {
  return JSON.parse(JSON.stringify(myIntro))
}
let copyMe = deepClone(myIntro)
copyMe.like = 'Front End'
console.log(myIntro, copyMe)
// { age: 25, like: 'FE' } { age: 25, like: 'Front End' }
```

> 特别注意：`JSON.stringify(Infinity)` 之后，会存储的是 null，读取后，不是 Infinity
>
> 以下情况使用 `JSON.stringify()` 可能会出错，请确保使用前没有一下情况出现。
>
> - 转换属性值中有 toJSON 方法时。方法不会被JSON.stringify 识别，但如果是 toJSON，该方法会直接被执行，并且不会返回生成的字符串。详见例1。
> - 被转换值中有 undefined、任意的函数以及 symbol 值。详见例2、例3
> - 值为 NaN 和 Infinity。详见例2、例3
> - 以 symbol 为属性键的属性
> - 包含循环引用的对象，objA引用 objB，并且 objB 引用 objA
> - 具有不可枚举的属性值时

```js
var num = Infinity
JSON.stringify(num) // "null"
```

```js
// 例1：
let author = {
  name:'fall',
  age:23,
  toJSON:function(){
    return "成功"
  }
}
JSON.stringify(author) // "\"成功\""
// 例2：
let author = {
  wife:undefined,
  money:Infinity,
  string:NaN,
  girlfriend:Symbol("she")
}
JSON.stringify(author) // "{\"money\":null,\"like\":null}"
// 例3
let nothing = [undefined,Infinity,NaN,Symbol("she")]
JSON.stringify(nothing)
// 例4
let author = Object.create(null, {
  name: { value: "fall", enumerable: true },
  age: { value: "23", enumerable: false },
})
JSON.stringify(author)
// {"name":"fall"}
```



## BOM

## DOM



## 内容参考：

| 作者   | 链接                                   |
| ------ | -------------------------------------- |
| Gopal1 | https://www.jianshu.com/p/b714dc8e068e |

