## 类

ES5中，类的声明

```js
function Person (x,y){
  this.x = x
  this.y = y
}
Person.prototype.logX= function (){
  console.log(this.x)
}
```

ES6中，类的声明

```js
class Person {
  constructor(this.x=x,this.y=y)
	logA(){
    console.log(this.x)
  }
}
```

ES5类的构造是可枚举的，即可通过 for...in 循环查找到的。ES6中的方法声明不能通过for...in查找到

## 超类super

```js
var parent = {
    foo() {
        console.log('Hello from the Parent')
    }
}
var self = {
    foo() {
        super.foo()
        console.log("这是你的")
    }
}
var son = {
    foo() {
        super.foo() // 调用父类的 foo()方法
        console.log('到底是啥鸟')
    }
}
Object.setPrototypeOf(self, parent) // 把自己作为子类赋值给父类
Object.setPrototypeOf(son, self)
son.foo()
```

## 数据操作

### 迭代器

提供了`next()` 遍历一个序列

```js
var arr = [11,12,13];
var itr = arr[Symbol.iterator]();// 自定义一个对象的迭代器
 
itr.next(); // { value: 11, done: false }
itr.next(); // { value: 12, done: false }
itr.next(); // { value: 13, done: false }
 
itr.next(); // { value: undefined, done: true }
```

### Generators

Generator 函数是 ES6 的新特性，它允许一个函数返回的可遍历对象生成多个值。

在使用中你会看到 * 语法和一个新的关键词 yield:

`*` 用于确定生成一个迭代器，`yield` 表示返回的迭代器

```js
function *infiniteNumbers() {
  var n = 1;
  while (true){
    yield n++;
  }
}
var numbers = infiniteNumbers(); // returns an iterable object
 // 每次返回值，值会变成下一个
numbers.next(); // { value: 1, done: false }
numbers.next(); // { value: 2, done: false }
numbers.next(); // { value: 3, done: false }
```

### 数组扩展

- 数组扩展运算符（...）将数组展开成用逗号分隔的参数序列，只能展开一层数组：

```js
// 应用一：函数传参
Math.max(...[1, 2, 3])  // 3

// 应用二：数组合并
let merge = [...[1, 2], ...[3, 4], 5, 6]  // 1, 2, 3, 4, 5, 6

// 应用三：浅克隆
let a = [1, 2, 3]
let clone = [...a]
a === clone  // false

// 应用四：数组解构
const [x, ...y] = [1, 2, 3]
x  // 1
y  // [2, 3]
```

### 类数组对象argument

argument 本身是一个对象

```js
function fun(){
  console.log(argument[0]) // argument[0] 的值为 99
  console.log(argument[3]) // undefined
}
fun(99,23,45)
```



