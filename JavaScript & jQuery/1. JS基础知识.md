## 数据类型


- **Data Types**（六个数据类型） ：undefined、Boolean、Number、String、BigInt、Symbol
- **Structural Types** （两个构造类型）：Object、Function、
- **Structural Root** （一个原始数据类型）：null


## 字符串的存储

**字符串拼接**

```js
var a = '这是一个字符串'
var b = 'this is a string'
console.log(a + b)
```

**字符串特性**

```js
// 跨行声明字符串，需添加'\'进行转译
var str1 = 'hellow \
mybro';
// ECMA6 中添加新的符号，无需添加转译就可直接换行
var str2 = `hellow 
mybro`;
// 新的的字符串拼接方法，以及函数中传入对象
function file({name,age,gender}){
    console.log(`我叫${name}，今年${age}岁，性别${gender}`);
};
file({
    name:'小明',
    gender:'男',
    age:22,
});
// 循环 emoji
let str = '😀🤣😜😍🤗🤔'
    for (const emoji of str) {
      console.log(emoji) // 😀🤣😜😍🤗🤔
    }
    for (let i = 0, l = str.length; i < l; i++) {
      console.log(str[i])  // 不能正确输出表情
    }
```

## 对象和类

### 面向过程和面向对象

**面向过程**：只考虑数学逻辑

**面向对象**：将生活逻辑映射到程序中

-  分析有哪些实体
-  分析设计各个实体的功能
-  实体间的相互作用

### 创建新的对象

```javascript
// 三种不同的声明方式
var obj1 = new Object();
var obj2 = Object();
var obj3 = {
  username : "iron-man"
  show:function
}
// 添加属性和方法
obg3.username = "white house"
obj3.show = function(){}
// 不同的输出方式
alert(obg3.username)
alert(obg3[username])
// 删除方法
delete obg3.username 
```

### 创建类

```js
// 类，是 ES6 中新添加的
class Hero{
  heroName
  level
  constructor(heroName,level){ // 可以通过设置默认值(heroName="未知",level="未知")
    this.heroName = heroName
    this.level = level
  }
  callMyName(){
    console.log(`作为一个英雄，我的名字是${this.heroName},我是${this.level}等级`)
  }
}
const bicycle = new Hero('单车骑士',"二级甲等")
bicycle.callMyName() 
```



### 什么是类，什么是对象

- **类**：对象特征的集合

- **对象**：具体的某一个事物

## Number

### 不同进制数据

二进制：

八进制：通过在数字前面添加 0 即可将其转换为八进制值

十六进制：前面添加`0x`即可

## 数组

### 数组的方法

| 方法              | 作用                                                   |
| ----------------- | ------------------------------------------------------ |
| `array.length`    | 数组的长度                                             |
| `array.concat()`  | 返回连接后的数组                                       |
| `array.join()`    | 用 join 传入的数据，将数组连起来，生成一串字符串后返回 |
| `array.reverse()` | 使数组逆序                                             |
| `array.indexOf()` | 对元素进行查找，并且返回下标                           |
| `array.slice()`   | 返回数组的一部分                                       |
| `array.sort()`    | 根据字符排序                                           |
| `arry.toString()` | 将数组转换成为以`,`分隔的字符串                        |
| `array.splice()`  | 保留()个数组元素，删除其他元素并返回                   |
| `array.pop()`     | 删除并且返回数组最后一个元素                           |
| `array.push()`    | 从后面给数组添加元素                                   |
| `array.shift()`   | 删除并且返回数组第一个元素                             |
| `array.unshift()` | 在头部插入一个元素                                     |

### 数组的方法详解

**filter 过滤**

```js
var arr = [11,22,33,44,55];
var newarr = arr.filter(function(item){
    return item>20
});
var newarr = arr.filter(item=>item>20)
```

**find 查找**

​	返回第一个符合条件的元素

```js
var arr = [12,24,33,68,55];
res = arr.find(function(item,index,arr){
    return item>20
})
console.log(res)
var arr2 = [12,24,33,68,55];
res = arr.find(item => item>20)
```

`findIndex()`

- 返回第一个符合条件的元素下标

```js
var arr = [11,20,30,40,50];
var newarr = arr.filter(function(item,index,arr){
    return item>20;
})
```

`copyWithin(a,b,c)`

- 从a开始，用b到c的数对原数组进行覆盖

```js
var arr = [11,22,33,44,55,66];
var newArr = str.copyWithin(1,0,2);
// 执行后新数组是11,11,22,44,55,66
alert(newstr);
```

## 集合

### **set集合**

> set集合的特点：
>
> - 键值对相同
> - .add 可以进行添加
> - 所有值不重复

```js
let imgs = new Set()
imgs.add(100)
imgs.add('hello')
imgs.add('hello')
imgs.add(true)
imgs.add(new String('world'))
```

> `WeakSet`  同Set，意思就是 `WeakSet` 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题

### **map集合**

> Map集合的特点
>
> - map集合传值必须使用键值对进行添加

```js
let map = new Map();
map.set('张三',"吃饭的");
map.set("六六","喝水的");
map.set("六六","吃药了");

console.log(map);
// Map对象取值
alert(map.get('六六'));
//Map集合的遍历
```

> `WeakMap`  同Set，意思就是 `WeakMap` 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题



## 数组、对象、集合的遍历

### **数组的遍历**

```js
var arr = [10,22,33,44,55,66];
//1. for 循环
	for(var i = 0;i<arr.length;i++){
		document.write('for循环'+i+','+arr[i])
	}
//2. for in 
	for(var i in arr){
		document.write('for in 循环'+ i+','+ arr[i])
	}
//3. forEach
	arr.forEach((item,index,arr)=>{
		document.write('forEach'+index+','+item)
	});
	arr.forEach(item =>{
    console.log(item)
  })
// 4. for...of
for(item of arr){
  document.write("for...of"+item +"<br>")
}
```

### 对象的遍历

使用 for...of 遍历对象会报错

```js
// for in
var person = {
	username :'iron man',
	age:28,
  gender:"male"
}
for(var attr in person){
    document.write("对象的遍历:"+attr+'分隔'+person[attr]+"<br>")
}
```

### 集合的遍历

map 集合的遍历

集合使用 for...in 不会出任何结果

```js
var map = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
// 对map进行循环
for (let item of map) {
    console.log(item[0],item[1])
}
// 将item解构
for(let [key,value] of map){
    console.log(key,value)
}
```

set 的遍历

```js
var mySet = new Set(['闪电','flash','too'])
console.log(mySet)
mySet.forEach(item => {
    console.log(item)
})
mySet.forEach(function(item){
    console.log(item)
})
// 以键值对的方式进行循环
for (let item of mySet.entries()) {
    console.log(item)
} 
// 以键的方式进行循环
for (let item of mySet.keys()) {
    console.log(item)
}
```

## 数组方法和合并对象

- `Array.form()`
  - 功能：将伪数组转化为真数组
- `Array.find()`
  - 功能：找到数组中符合条件的元素，只返回第一个找到的元素
- `Array.copyWithin()`
  - 功能：对函数进行覆盖
    - 第一个参数表示起始位置，
    - 第二和第三个参数表示想去覆盖的数组
    - 结果是从第一个参数开始，将会被覆盖

```js
var aLis = document.getElementsByTagName('li');
aLis = Array.form(alis);
aLis.push('hello')
```

`Object.assign(obj1,obj2,obj3);`

浅拷贝，除数组外会生成一个全新的变量，但是数组只会指向原数组，原数组改变，assign的值也会改变

- 浅拷贝：数组会指向原来的地址，修改原来地址下的数据，拷贝后的数据也会改变

- 深拷贝：直接生成一组新的数据，和原先的数据没有关系，两个值相互独立

```js
var obj1 = {
    a:22,
    b:33
} 
var obj2 = {
    c:'ss',
    d:44
}
var obj3 = {
    d:'nn',
    e:['hello',55,66,789]
}
Object.assign(obj1,obj2,obj3);
obj3.e.push('ssh');
console.log(obj3);
console.log(obj1);
```

## 严格模式

严格模式是啥子？就是更加严格的模式！

use strict 是一种运行时自动执行更严格的 JavaScript 代码解析和错误处理的方法。如果代码错误被忽略或失败，将会产生错误或抛出异常。

非严格模式下

```js
a = 100
console.log(a) // 100
```

严格模式下

```js
"use strict"
a = 100
console.log(a) // 我直接给你报错！
```

> ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 "use strict"

**严格模式主要有以下限制：**

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用 with 语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀 0 表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量delete prop ，会报错，只能删除属性 selete global[prop]
- eval 不会在它的外层作用域引入变量
- eval和arguments不能被重新赋值
- arguments不会自动反映函数参数的变化
- 不能使用arguments.callee
- 不能使用arguments.caller
- 禁止this指向全局对象，此 this 指向 undefined，能避免在顶层使用 this，和顶层使用 this 报错。
- 不能使用fn.caller和fn.arguments获取函数调用的堆栈
- 增加了保留字（比如protected、static和interface）

严格模式是ES5引入的，上面这些限制，模块都必须遵守。

严格模式的好处啥的：

- 使调试跟更容易。如果代码错误本来会被忽略或失败，那么现在将会产生错误或抛出异常，从而更快地发现代码中的问题，并更快地指引它们的源代码。

- 防止意外全局。如果没有严格模式，将指赋值给未声明的变量会自动创建一个具有该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，会直接报错。

- 消除隐藏威胁。在没有严格模式的情况下，对null或undefined的这个值得引用会自动强制到全局。这可能会导致需要headfakes和pull-out-your-hair类型的错误。在严格模式下，因公用null或undefined的这个值会引发错误。

- 不允许重复的参数值。严格模式在检测到函数的重复命名参数（例如，函数foo（var1，var2，var1）{}）时会引发错误，从而捕获代码中几乎可以肯定存在的错误，否则会浪费大量的时间追踪命名上的问题。

  > 注意：它曾经是（ECMAScript 5 中）strict模式将禁止重复的属性名称（例如var object = {foo：“bar”，foo：“baz”}；）但是从ECMAScript 2015 开始，就不再有这种情况了。 

- 使`eval()`更安全。eval（）在严格模式和非严格模式下的行为方式有些不同。最重要的是，在严格模式下，在eval（）语句内部声明的变量和函数不会再包含范围中创建（它们是以非严格模式在包含范围中创建的，这也可能是问的常见来源）。

- 抛出无效的使用错误的删除符。删除操作符（用于从对象中删除属性）不能用于对象的不可配置属性，当试图删除一个不可配置的属性时，非严格代码将自动失败，而在这种情况下，严格模式会引发错误

## 参考文章：

| 文章标题                  | 地址                                                       |
| ------------------------- | ---------------------------------------------------------- |
| "use strict" 的意义和好处 | https://blog.csdn.net/qq_36379070/article/details/82586892 |

