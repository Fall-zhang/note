## Proxy

代理，用来定义基本操作的自定义行为，对被代理对象 `target` 操作之前会先进行拦截。

```js
// 创建代理对象，代理对象内有两个对象，一个是 target，表示被监听对象，另一个是 handler，表示做如何处理
let proxy = new Proxy(target,handler)
// 代理对象的使用
let instance = new Proxy({user:'fall'},{
  // 分别返回的是代理对象，当前获取的键，整个instance对象
  get(target,propKey,receiver){
    return `你好啊，${target.name}`
  },
  set(target,propKey,receiver){},
  deleteProperty(target,prop){}
})
instance.name // '你好啊，fall'
```

是

```js

```



果 `handler` 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上（对代理赋值，直接作用于 target）

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.name = '布兰'
target.name  // '布兰'
```

### 关键字

关键字一共有一下好多个

- get 用于拦截属性的读取操作
- 

```js
let target={
  name:'fall'
}
let proxy = new Proxy(target, {
  get(target,propKey,receiver){},   // 拦截对象属性的读取，target指的是被代理的对象， propKey 指受到操作的对象，receiver 表示改 Proxy 对象
  set(target,propKey,value,receiver){}, // 拦截对象属性的设置代理对象 proxy 指的是
  has(target,propKey){},       // 拦截 propKey in proxy 操作，返回一个布尔值
  deleteProperty(target,propKey){}, // 拦截删除propKey的操作
  ownKeys(target){}            // 拦截多个Object操作，返回一个数组，数组包括所有值，不同于Object.keys()，可以返回Symbol对象
})
```



### 静态方法

`Proxy.revocable()` 定义一个可撤销的Proxy

```js
let target = {}
let handler = {}
let {proxy, revoke} = Proxy.revocable(target, handler)

proxy.foo = 123
proxy.foo  // 123
revoke()
proxy.foo  // TypeError
```

### 示例

示例放在了Reflect的实例中，下面

```js

```

## Reflect

和 Proxy 相同，Reflect作用是恢复到原来的默认值操作

- `Reflect` 是一个内置的对象，它提供拦截 `JavaScript` 操作的方法。这些方法与 `proxy handlers` 的方法相同。`Reflect` 不是一个函数对象，因此它是不可构造的。
- 设计的目的：
  - 将 `Object` 属于语言内部的方法放到 `Reflect` 上；
  - 修改某些 `Object` 方法的返回结果，让其变得更合理；
  - 让 `Object` 操作变成函数行为
  - `Proxy handles` 与 `Reflect` 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 

### 静态方法

- `Reflect.apply(target, thisArgument, argumentsList)` 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 `Function.prototype.apply()` 功能类似；
- `Reflect.construct(target, argumentsList[, newTarget])` 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`；
- `Reflect.defineProperty(target, propertyKey, attributes)` 和 `Object.defineProperty()` 类似。如果设置成功就会返回 `true`；
- `Reflect.deleteProperty(target, propertyKey)` 作为函数的 `delete` 操作符，相当于执行 `delete target[name]`；
- `Reflect.get(target, propertyKey[, receiver])` 获取对象身上某个属性的值，类似于 `target[name]`；
- `Reflect.getOwnPropertyDescriptor(target, propertyKey)` 类似于 `Object.getOwnPropertyDescriptor()`。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 `undefined`；
- `Reflect.getPrototypeOf(target)` 类似于 `Object.getPrototypeOf()`；
- `Reflect.has(target, propertyKey)` 判断一个对象是否存在某个属性，和 `in` 运算符 的功能完全相同；
- `Reflect.isExtensible(target)` 类似于 `Object.isExtensible()`；
- `Reflect.ownKeys(target)` 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 `Object.keys()`, 但不会受 `enumerable` 影响)；
- `Reflect.preventExtensions(target)` 类似于 `Object.preventExtensions()`。返回一个 `Boolean`；
- `Reflect.set(target, propertyKey, value[, receiver])` 将值分配给属性的函数。返回一个 `Boolean`，如果更新成功，则返回 `true`；
- `Reflect.setPrototypeOf(target, prototype)` 设置对象原型的函数. 返回一个 `Boolean`， 如果更新成功，则返回 `true`；

Proxy和Reflect是成对出现的，所以合起来就有一个示例

### 示例

```js
// 这段代码中有地方完蛋了，看看错在哪了
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般就不用添加这个参数了）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return Reflect.get(target, propKey) // 如果想要使用默认获取值的操作，使用该返回值
  },
  set(target,propKey,receiver){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是赋的值 此处为 23
    // target[propKey] = receiver //在此处意为：将staff.age 设置为 23 
    return Reflect.set(target,propKey,receiver) // 如果想要使用默认获取值的操作，使用该返回值
  },
  deleteProperty(target,propKey){
    console.log(target) 			// target 指向的是 staff 
    console.log(propKey)			// propKey 指向的是 key age
    return Reflect.deleteProperty(target,propKey) // 如果想要使用默认获取值的操作，使用该返回值
  } 
})

delete proxyStaff.age
proxyStaff.age= 23
console.log(proxyStaff.age);
```



## Class

### 语法特性

Class 就是 ES6 中创建类的语法糖

可以用 `class` 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把狗定义为一个类，狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 `name` 属性

```js
// 类声明
class Dog {
  constructor(name) { // 在创建对象时会构造一次
    this.name = name
  }
  bark() {}
  jump() {}
}
Dog.name  // 'Dog'

// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）
let Animal2 = class {
  // xxx
}
Animal2.name  // 'Animal2'
```

`JS` 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 `ES5` 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：

```js
class Dog {
  constructor() {}
  bark() {}
  jump() {}
}
Object.keys(Dog.prototype)  // [] 类的内部方法是不可被迭代的

// 类似于
function Dog2(){}
Dog2.prototype = {
  constructor() {},
  bark() {},
  jump() {},
}
Object.keys(Dog2.prototype)  // ['constructor', 'bark', 'jump'] function可以被迭代
```

基于原型给类添加新方法

```js
Object.assign(Dog.prototype, {
    eat() {} 
})
```

- 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，`getter`和 `setter` 都在严格模式下执行。
- 类内部的 `this` 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 `this` 指向运行时的环境，而类内部是严格模式，所以此时的 `this` 会是 `undefined`：

```js
class Dog {
  constructor(name) {
    this.name = name
  }
  bark() {
    console.log( `${this.name} is bark.` )
  }
  static jump() {
    console.log( `${this.name} is jump.` )
  }
}
let dog = new Dog('大黄')
let { bark } = dog
let { jump } = Dog
bark()  // TypeError: Cannot read property 'name' of undefined
jump()  // TypeError: Cannot read property 'name' of undefined
```

### 方法和关键字

`constructor` 方法是类的默认方法，通过 `new` 关键字生成实例的时候，会自动调用；`constructor` 默认会返回实例对象：

```js
class Point {}
// 一个类必须有 constructor 方法，如果没有显示定义，则会自动添加一个空的，同下
class Point {
    constructor() {}
}
```

通过 `get` 和 `set` 关键字拦截某个属性的读写操作：

```js
class Dog {
    get age(){
        return 1
    }
    set age(val){
        this.age = val
    }
}
```

用 `static` 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：

```js
class Dog {
    bark() {}
    jump() {
        console.log('原型方法')
    }
    static jump() {
        console.log('静态方法')
    }
}
Object.getOwnPropertyNames(Dog.prototype)  // ['constructor', 'bark', 'jump']
Dog.jump()  // '静态方法'
let dog = new Dog()
dog.jump()  // '原型方法'
```

`new.target` 属性允许你检测函数、构造方法或者类是否是通过 `new` 运算符被调用的。在通过 `new` 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是 `undefined`，子类继承父类的时候会返回子类：

```js
class Dog {
    constructor() {
        console.log(new.target.name)
    }
}
function fn(){
    if (!new.target) return 'new target is undefined'
    console.log('fn is called by new')
}
let dog = new Dog()  // 'Dog'
fn()                 // 'new target is undefined'
new fn()             // 'fn is called by new'
复制代码
```

**类的继承**：

类可以通过 `extends` 关键字实现继承，如果子类显示的定义了 `constructor` 则必须在内部调用 `super()` 方法，内部的 `this` 指向当前子类：

```js
class Animal {
    constructor(name) {
        this.name = name
    }
    run() {
        console.log(`${this.name} is running.`)
    }
}   
class Dog extends Animal{
    constructor(name){
        super(name)  // 必须调用
        this.name = name
    }
    bark() {
        console.log(`${this.name} is barking.`)
    }

}
let dog = new Dog('大黄')
dog.run()  // '大黄 is running.'
复制代码
```

通过 `super()` 调用父类的构造函数或者通过 `super` 调用父类的原型方法；另外也可以在子类的静态方法里通过 `super` 调用父类的静态方法：

```js
// 基于上面的代码改造
class Dog extends Animal{
    constructor(name){
        super(name)  // 调用父类构造函数
        this.name = name
    }
    bark() {
        super.run()  // 调用父类原型方法
        console.log(`${this.name} is barking.`)
    }
}
let dog = new Dog()
dog.bark()s
// '大黄 is running.'
// '大黄 is barking.'
```

子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的prototype属性：

```js
class Animal {}
class Dog extends Animal {}

Dog.__proto__ === Animal  // true
Dog.prototype.__proto__ === Animal.prototype  // true
```

子类原型的原型指向父类的原型：

```js
// 基于上面的代码
let animal = new Animal()
let dog = new Dog()
dog.__proto__.__proto__  === animal.__proto__  // true
```

使用 `extends` 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：

`String()`、`Number()`、`Boolean()`、`Array()`、`Object()`、`Function()`、`Date()`、`RegExp()`、`Error()`

```js
class MyString extends String {
    constructor(name){
        super(name)
        this.name = name
    }
    welcome() {
        return `hello ${this.name}`
    }
}
let ms = new MyString('布兰')
ms.welcome()      // 'hello 布兰'
ms.length         // 2
ms.indexOf('兰')  // 1
```

### 实验性功能

**公有字段和私有字段**

静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：

```
class Dog {
	age = 12,                   // 公有字段
	static sex = 'male',        // 静态公有字段
	#secret = '我是人类的好朋友'  // 私有字段
	#getSecret() {              // 私有方法
		return this.#secret
	}
}
Dog.sex  // 'male'
let dog = new Dog()
dog.#getSecret()  // SyntaxError
```

> 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。

## Promise

先承诺好解决方案，如果正确，采用正确的解决方案，如果错误，采用错误的解决方案

- 如果返回值 promise 实例对象，会调用下一个then
- 如果是一个普通的返回值，会通过then接收普通测传入的值

Promise 是用来管理异步编程的，**它本身不是异步的**，Promise用于防止陷入回调地狱。

> 了解 Promise 的工作方式是了解 `async` & `await` 的基础，因为这些异步函数在底层使用了 `promise`
>
> 当 promise 被调用后，它会以处理中状态开始，此时调用的函数会继续执行，而 promise 仍在处理中直到解决为止，从而为调用的函数提供所请求的任何数据。被创建的 promise 最终会以**被解决状态或被拒绝状态**结束，并在完成时调用相应的回调函数（传给 `then` 和 `catch`）。

那些 JS API 使用了 Promise?

- Battery API
- Fetch API
- Service Worker

### Promise 的使用

```js
var p = new Promise(function(resolve, reject) {
  if (/* 条件 */) { // 符合条件，执行成功的函数resolve
    resolve(/* value */);  
  } else {
    // 不满足条件，执行reject
    reject(/* reason */);  
  }
});
// 方法一：p.then()内传入两个方法，
// 第一个方法执行成功后执行 resolve 中的函数
// 第二个方法执行方法的传入值为 reject 的参数 
p.then((result)=>{
  /* 成功后的执行内容 */
},(reason)=>{
  /* 失败后的执行内容 */
})
// 方法二：成功的内容通过.then()获取。失败的内容也可以通过 .catch() 进行捕获
p.catch((err)=>{throw new Error('错误')})
.catch(err)=>{console.log(err)}
// 如果捕获错误中出现错误，可以添加第二个catch来补获
```

> 在 promise 中的错误会像冒泡一样，如果出现一个错误，那么接下来的也都会错误。但可以利用这一特性——在最后调用的接口上实现对于错误的处理，实现简化错误操作。
>
> 注：实现该特性需要两点注意，第一点每次调用 then 都要返回一个新的 Promise ；不管第一个参数的返回值是什么

> 是否执行 `reslove` , `reject` 都是取决于是否执行 `reslove()` & `reject()` 或者是函数本身出现异常

**当执行的函数出现错误时**

```js
new Promise(resolve=>{
  resolve(a)
  // 由于 a 没有定义，所以执行错误返回
}).then(result=>{
  console.log("成功"+result)
},reason=>{
  console.log("失败"+reason)
}).then(result=>{
  console.log("success"+result)
},reason=>{
  console.log('failure')
})
// 该函数第一次执行失败，调用失败的函数，输出原因
// 第二次由于没有返回值，以成功执行计算
// 个人理解，第一个 then 判断的是 Promise 对象执行成功与否，第二个 then 用来判断第一个 then 执行的成功与否
```

> Promise 能解决回调地狱的问题，但是由于充满了 then 方法，使得可读性不强，所以使用 `async & await` 作为语法糖，很多人认为 `async & await` 就是回调地狱的最终解决方案。

### Promise 的嵌套调用

```js
const pr = new Promise((resolve) => {
  setTimeout(() => {
    console.log(999)
  }, 1000)
  resolve('666')
})
pr.then((result) => {
  console.log("1111"+result)
  return Promise.resolve("bbbb")
  /* 
  Promise.resolve("bbbb")等价于 
	new Promise(resolve=>{
		resolve("bbbb")
	})
*/
})
  .then((result) => {
    console.log('吃人的东西'+result)
  })
  .catch((err) => {
    console.log('出错了，玛德' + err)
  })
```

### Promise 的API

`Promise.resolve()`

> `Promise.resolve()` 返回一个给定值解析后的 Promise 对象
>
> `Promise.resolve('foo')` 
>
> 等价于`new Promise(resolve => resolve("foo"))` 新建了一个执行成功，并且返回 `foo` 的 Promise 对象

`Promise.reject()`

> 返回一个带拒绝原因的 Promise 对象
>
> 注：调用`reject` 和 `resolve` 之后Promise的使命就完成了，因此，操作不应该放在 `Promise` 对象中，而应该放置在 `then` 中执行。

`Promise.all()`

> 当返回的数组中所有的 Promise 对象的返回值都为 resolve 时，才会执行相应的 Promise，有一个出错，其他的 Promise 也无法执行

```js
let p1 = Promise.resolve(1)
let p2 = Promise.resolve(2)
Promise.all([ p2, p1])
  .then(result => {
 // 返回的结果是按照Array中编写实例的顺序来
    console.log(result) // [ 2, 1 ]
  })
  .catch(reason => {
    console.log("失败:reason")
  })
```

`Promise.allSettled()`

> ES2020 引入的 `allSettled` 方法用于确保所有操作都结束
>
> 假设一个页面有三个区域，分别对应三个独立的接口数据，使用 `Promise.all`  来并发请求三个接口，如果其中任意一个接口出现异常，状态是 reject ,这会导致页面中该三个区域数据全都无法出来，`Promise.allSettled` 的出现就可以解决这个问题

`Promise.race()`

> `Promise.race`只要有一个 promise 对象进入 `FulFilled ` 或者 `Rejected` 状态的话，就会继续进行后面的处理。

```js
function timerPromisefy(delay) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(delay);
        }, delay);
    });
}
// 任何一个 promise 率先变为 resolve 或 reject 的话程序就停止运行
Promise.race([
    timerPromisefy(1),
    timerPromisefy(32),
    timerPromisefy(64)
]).then(function (value) {
    console.log(value);    // => 1
});
```

`Promise.finally()`

> 无论执行成功或者失败与否，都会在最后执行这个 finally 中的函数

```js
this.loading = true
request()
  .then((res) => {
    // do something
  })
  .catch(() => {
    // log err
  })
  .finally(() => {
    this.loading = false // 无论成功与否，都想把 loading 转换为 false
  })
```

## async & await

### async 的特点

- 语法简洁，更像是同步代码，也更符合普通的阅读习惯
- 改进JS中异步操作串行执行的代码组织方式，减少callback的嵌套
- Promise 中不能自定义使用 `try/catch` 进行错误捕获，但是在 `async/await` 中可以像处理同步代码处理错误。

await 将异步代码改造成了同步代码，这会导致多个异步代码**没有依赖性却使用了 await 会导致性能上的降低**。

await 意思是，等待 await 里面的函数全部执行完成，再接着执行该 async 函数。并且在接着执行该函数之前，先执行其他函数。

`async/await` 的实现是基于 Promise的，`async` 关键字意味着该函数会返回 `promise`，是 generator 的语法糖。

### async 的实例

```js
const fun1 = async ()=>{
  return '测试'
}
fun1().then(alert)
// fun1 等价于 fun2
const fun2 = ()=>{
  return Promise.resolve('测试')
}
```

只有 await 右边返回为 resolve 才会继续执行，否则直接中断

```js
let p1 = Promise.reject(100)
async function fn1() {
  let result = await p1
  console.log(1) // 这行代码不会执行
}
```

**async 函数的执行顺序**

```js
let p1 = Promise.resolve(1)
let p2 = new Promise(resolve=>{
  setTimeout(()=>{
    resolve(2)
  },2000)
})
async function fun(){
  console.log(1)
  let resu2 = await p1 // 等待返回 resolve ,返回 resolve 后继续执行
  console.log(3)
  let resu1 = await p2
  console.log(4)
}
fun()
console.log(2)
```

> 任务队列（宏任务）
>
> 基于微任务的技术有 `MutationObserver`、`Promise` 以及以 `Promise` 为基础开发出来的很多其他的技术。
>
> 不管宏任务是否到达时间，以及放置的先后顺序，每次**主线程执行栈为空的时候**，引擎会优先处理微任务队列，**处理完微任务队列里的所有任务**，再去处理宏任务。

根据HTML5 的标准，`setTimeout()`最少为 4 ms

