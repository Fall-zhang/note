## 文件操作对象

总共有五个大对象，Blob、ArrayBuffer、File、FileReader和FormData

- Blob、ArrayBuffer、File可以归为一类，它们都是数据；
- FileReader算是一种工具，用来读取数据；
- FormData可以看做是一个应用数据的场景。

### Blob

Blob 全称是`binary large object`，Blob对象就是一个包含有只读原始数据的类文件对象，通俗讲就是不可修改的二进制文件。

```js
var aBlob = new Blob( array, options );
// array：一堆数据构成的数组 
// options：设置一些属性，主要是type属性
// 此时 aBlob 是一个对象，拥有 size,type 两个属性。
let aBlob = new Blob([101])
// 新的对象上有两个属性，size，type
// size 
// type 就是 MIME类型，一般来讲就是
aBlob // {size: 3,type:''}
```

Blob 上的方法只有一个

```js
Blob.slice(start, end ,contentType)
//start:分割起始点
//end: 分割终点
//contentType:新的MIME类型
```

### File

File 对象继承自 Blob，也是二进制对象，通常用在`<input type='file'>` 选择的 FileList 对象。或者是拖拽产生的`DataTransfer`对象。

```js
var oneFile = new File(array,name,options)
// array 数据构成的数组
// name 文件名
// options 设置一些属性，Type属性，lastModified
oneFile //name,size,lastModified,lastModifiedDate,type
// 对象上的属性
// name 文件名
// size 文件大小
// lastModified 最后修改的时间
// lastModifiedDate 最后修改时间的 Date 对象
// type MIME类型
```

方法也只有一个，也是继承自 Blob

```js
Blob.slice(start, end ,contentType)
// start:分割起始点
// end: 分割终点
// contentType:新的MIME类型
```

### ArrayBuffer

内存上的一段二进制数据，可以通过 TypeArray、DataView 对它是先读写

Blob 与 ArrayBuffer 的关系

- ArrayBuffer是底层的二进制数据，可以借助工具进行读写，Blob是对底层数据的封装，拿到的是一个整体，你能看到大小，类型，但是不能看到细节。
- Blob可以接受一个ArrayBuffer作为参数生成的一个Blob对象，相当于ArrayBuffer的一个封装，之后就是整体展现了。

> Blob作为一个整体的文件，适合用于传输。只有关注文件的细节修改一部分的数据，才会用到ArrayBuffer。

### FileReader

FileReader可以将Blob、File读取为不同的格式。

FileReader.readAsDataURL(blob) 将数据转化为Base64

FileReader.readAsText(blob)将二进制数据读取并编码为字符串形式



### FormData

异步上传二进制文件

### 对象的互相转换

```js
// file 转换为 Blob
let aBlob = new Blob([file],{type:file.type})
// Blob 转化为 File
let oneFile = new window.File([Blob])
// File/Blob转化为 base64
function toDataURL(blob,callBack){
  let a = new FileReader()
  a.onload = function (e){callback(e.target.result)}
  a.readAsDataURL(blob)
}
```

URL 转化为 base64

```js
function transURL(url){
  let image = new Image()
  image.src = url
}
```



## 上传文件

场景：单文件、多文件、目录上传、压缩目录上传、拖拽上传、剪贴板上传、大文件分块上传、服务端上传。

### 单文件上传

**前端代码**

```html
<input id='uploadFile' type="file" accept="image/*"/>
<button id='submit' onclick='uploadFile()'>  上传文件  </button>
```

其中 accept 用于限制上传文件类型。IE9 以下不支持该属性

- `image/*` 限制只能上传 image 文件
- `image/png` 限制只能上传png
- `image/png,image/jpeg` 限制只能上传png和jpg

> accept只进行限制后缀名，把后缀名更改还是可以绕过检测，而想实现只接受特定的格式，使用其他工具，或者是看这个教程 [如何区分图片类型](https://juejin.cn/post/6971935704938971173)。

**JS代码**

```js
const uploadFileEle = document.querySelector('#uploadFile')
const request = axios.create({
  baseURL:'http://localhost:8080/upload',
  timeout:60000
})
// 判断是否存在文件，获取文件，进行上传
async functioin uploadFile(){
  if(!uploadFileEle.files.length) return
  const file = uploadFileEle.files[0]
  upload({
    url:'/single',
    file
  })
}
function upload({url,file,fieldName='file'}){
  let formData = new FormData()
  formData.set(fieldName,file)
  request.post(url,formData,{
    onPuloadProgress:function(progressEvent){
      const percentCompleted = Math.round(
      (progressEvent.loaded*100)/progressEvent.total)
    }
    console.log(percentCompleted)
  })
}
```

上述代码先把读取的File对象封装成FormData对象，然后利用Axios的post实现文件上传的功能。再上传之前，通过请求配置对象的onUploadProgress 就可以获取文件的上传进度。

**服务端代码**

Koa框架。实现的服务端代码。

## 参考文章

| 作者     | 连接                                       |
| -------- | ------------------------------------------ |
| controZL | https://juejin.cn/post/6915795898609975309 |
| 阿宝哥   | https://juejin.cn/post/6980142557066067982 |
|          |                                            |
|          |                                            |
|          |                                            |

