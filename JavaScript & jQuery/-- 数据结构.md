## 数据结构

数据结构用于展现数据之间的逻辑关系，存储关系，操作关系。

数据结构主要有哪些？

栈，队列，链表，集合，哈希表，树，字典，图。

## Set

Set 是一个键值统一的数据结构，可以近似理解为是数组，只不过数组的下标和数组的单项内容相同，可以通过传入一个数组，实现对于数组的构造。

```js
const cc = new Set([1,2,2])
cc // Set([1,2])
const ss = new Set('unique')
ss // Set('u','n','i','q','e')
```

在 `Set` 内部判断两个值是否相等使用的是 `sameValueZero` 算法，需要注意条件和`===`差不多，只有一个例外，`NaN`和`NaN` 会被认为相同。

```js
let cc = new Set([NaN,NaN])
cc.size  // 1
// 只要对象不指向同一个地址，就不会因为重复被筛选掉
var a = {title:'leaf'}
var b = {title:'leaf'}
var c = a
let set1 = new Set()
set1.add(a);set1.add(b);
set1.size // 2
let set2 = new Set()
set2.add(a);set2.add(c)
set2.size // 1
let set3 = new Set()
set3.add(a);set3.add({title:'leaf'})
set3.size   // 2
```

Set 是有顺序的，根据添加的顺序进行排序，通过 `for...of...` 进行遍历

```js
let set = new Set([1,3])
set.add('cs')
set.add('vc')
for(item of set){
  console.log(item)   // 1 3 'cs' "vc"
}
```

### 实例属性

```js
let set = new Set([1,2])
set.add(5)       // 向set内添加内容，返回 set
set.size         // 返回set的个数
set.delete(2)    // 删除元素，成功会返回true
set.has(2)       // 是否拥有 2
set.keys()       // 返回简明的遍历器
set.claer()      // 清空当前Set
```

### 应用场景

数组去重，字符串去重

```js
Array.from(new Set([1,3,4,2,1,3]))  //[1,3,4,2]
[...new Set([1,3,4,2,1,3])]         //[1,3,4,2]

[...new Set('unique')].join('') // uniqe
```

求交集，差集，并集

```js
let a = new Set('asd')
let b = new Set('asc')
let union = new Set([...a,...b])  // 并集
// 交集
let intersect = new Set([...a].filter(x=>b.has(x))) 
// 差集，a-b的差集
let diff = new Set([...a].filter(x=>!b.has(x)))
```

## WeakSet

和Set差不多，但是只能进行存储对象

**和 `Set` 的区别**：

- `WeakSet` 只能是对象的集合，而不能是任何类型的任意值；
- `WeakSet` 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 `WeakSet` 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 `WeakSet` 中没有存储当前对象的列表。正因为这样，`WeakSet` 是不可枚举的，也就没有 `size` 属性，没有 `clear` 和遍历的方法。

- `WeakSet.prototype.add(value)`：添加一个新元素 `value`；
- `WeakSet.prototype.delete(value)`：从该 `WeakSet` 对象中删除 `value` 这个元素；
- `WeakSet.prototype.has(value)`：返回一个布尔值,  表示给定的值 `value` 是否存在于这个 `WeakSet` 中；

## Map

不同于对象，对象的键只能是字符串或者 `Symbol`，而 `Map` 的键可以是任何类型（原始类型、对象或者函数），可以通过 `Map` 构造函数创建一个实例，入参是具有 `Iterator` 接口且每个成员都是一个双元素数组 `[key, value]` 的数据结构：

```js
// Map的声明和添加
const map = new Map()
map.set({},12) // 设置一个键值对，可以通过此方法无线设置键值对
// 并且可以通过二元数组设置为Map
var arr = [['name',"fall"],['age',23]]
const map1 = new Map(arr)
```

### 运算特性

如果键值出现了重复，后面的数据会覆盖前面的数据

```js
let map = new Map()
let foo = {foo: 'foo'}
map.set(foo, 'foo1')
map.set(foo, 'foo2')
map.get(foo)  // 'foo2' 
```

因为同set使用同样的 [sameValueZero](https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-samevaluezero) 算法，所以对于键名同为 `NaN` 以及相同对象而不同实例的处理同 `Set`

```js
let a = NaN
let b = NaN
let map = new Map()
map.set(a, 'a')
map.set(b, 'b')
map.size    // 1
map.get(a)  // 'b'
```

### 原型方法

`Map.prototype.size`：返回 `Map` 对象的键值对数量；

`Map.prototype.set(key, value)`：设置 `Map` 对象中键的值。返回该 `Map` 对象；

`Map.prototype.get(key)`： 返回键对应的值，如果不存在，则返回 `undefined`；

`Map.prototype.has(key)`：返回一个布尔值，表示 `Map` 实例是否包含键对应的值；

`Map.prototype.delete(key)`： 如果 `Map` 对象中存在该元素，则移除它并返回 `true`；

`Map.prototype.clear()`： 移除 `Map` 对象的所有键/值对；

`Map.prototype.keys()`：返回一个新的 `Iterator` 对象， 它按插入顺序包含了 `Map` 对象中每个元素的键；

`Map.prototype.values()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的值；

`Map.prototype.entries()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的 `[key, value]` 数组

`Map.prototype.forEach(callbackFn[, thisArg])`：按插入顺序遍历 `Map`；

```js
let map = new Map()
map.set({a: 1}, 'a')
map.set({a: 2}, 'b')
for (let [key, value] of map) {
    console.log(key, value)
}
// {a: 1} 'a'
// {a: 2} 'b'
for (let key of map.keys()) {
    console.log(key)
  // {a: 1}
	// {a: 2}
}
```

## WeakMap

- 类似于 `Map` 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 `WeakMap` 是不能被迭代的。

  ```js
  let wm = new WeakMap()
  let foo = {name: 'foo'}
  wm.set(foo, 'a')  // Weak
  wm.get(foo)       // 'a'
  wm.has(foo)       // true
  ```

  虽然 `wm` 的键对 `foo` 对象有引用，但是丝毫不会阻止 `foo` 对象被 `GC` 回收。当引用对象 `foo` 被垃圾回收之后，`wm` 的 `foo` 键值对也会自动移除，所以不用手动删除引用。

**实例方法**：

- `WeakMap.prototype.delete(key)`：移除 `key` 的关联对象
- `WeakMap.prototype.get(key)`：返回 key 关联对象, 或者 undefined（没有key关联对象时）
- `WeakMap.prototype.has(key)`：根据是否有 `key` 关联对象返回一个 `Boolean` 值
- `WeakMap.prototype.set(key, value)`：在 `WeakMap` 中设置一组 `key` 关联对象，返回这个 `WeakMap` 对象