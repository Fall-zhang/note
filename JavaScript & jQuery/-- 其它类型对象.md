## Set

Set 是一个键值统一的数据结构，可以近似理解为是数组，只不过数组的下标和数组的单项内容相同，可以通过传入一个数组，实现对于数组的构造。

```js
const cc = new Set([1,2,2])
cc // Set([1,2])
const ss = new Set('unique')
ss // Set('u','n','i','q','e')
```

在 `Set` 内部判断两个值是否相等使用的是 `sameValueZero` 算法，需要注意条件和`===`差不多，只有一个例外，`NaN`和`NaN` 会被认为相同。

```js
let cc = new Set([NaN,NaN])
cc.size  // 1
// 只要对象不指向同一个地址，就不会因为重复被筛选掉
var a = {title:'leaf'}
var b = {title:'leaf'}
var c = a
let set1 = new Set()
set1.add(a);set1.add(b);
set1.size // 2
let set2 = new Set()
set2.add(a);set2.add(c)
set2.size // 1
let set3 = new Set()
set3.add(a);set3.add({title:'leaf'})
set3.size   // 2
```

Set 是有顺序的，根据添加的顺序进行排序，通过 `for...of...` 进行遍历

```js
let set = new Set([1,3])
set.add('cs')
set.add('vc')
for(item of set){
  console.log(item)   // 1 3 'cs' "vc"
}
```

### 实例属性

```js
let set = new Set([1,2])
set.add(5)       // 向set内添加内容，返回 set
set.size         // 返回set的个数
set.delete(2)    // 删除元素，成功会返回true
set.has(2)       // 是否拥有 2
set.keys()       // 返回简明的遍历器
set.claer()      // 清空当前Set
```

### 应用场景

数组去重，字符串去重

```js
Array.from(new Set([1,3,4,2,1,3]))  //[1,3,4,2]
[...new Set([1,3,4,2,1,3])]         //[1,3,4,2]

[...new Set('unique')].join('') // uniqe
```

求交集，差集，并集

```js
let a = new Set('asd')
let b = new Set('asc')
let union = new Set([...a,...b])  // 并集
// 交集
let intersect = new Set([...a].filter(x=>b.has(x))) 
// 差集，a-b的差集
let diff = new Set([...a].filter(x=>!b.has(x)))
```

## WeakSet

和Set差不多，但是只能进行存储对象

**和 `Set` 的区别**：

- `WeakSet` 只能是对象的集合，而不能是任何类型的任意值；
- `WeakSet` 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 `WeakSet` 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 `WeakSet` 中没有存储当前对象的列表。正因为这样，`WeakSet` 是不可枚举的，也就没有 `size` 属性，没有 `clear` 和遍历的方法。

- `WeakSet.prototype.add(value)`：添加一个新元素 `value`；
- `WeakSet.prototype.delete(value)`：从该 `WeakSet` 对象中删除 `value` 这个元素；
- `WeakSet.prototype.has(value)`：返回一个布尔值,  表示给定的值 `value` 是否存在于这个 `WeakSet` 中；

## Map

不同于对象，对象的键只能是字符串或者 `Symbol`，而 `Map` 的键可以是任何类型（原始类型、对象或者函数），可以通过 `Map` 构造函数创建一个实例，入参是具有 `Iterator` 接口且每个成员都是一个双元素数组 `[key, value]` 的数据结构：

```js
// Map的声明和添加
const map = new Map()
map.set({},12) // 设置一个键值对，可以通过此方法无线设置键值对
// 并且可以通过二元数组设置为Map
var arr = [['name',"fall"],['age',23]]
const map1 = new Map(arr)
```

### 运算特性

如果键值出现了重复，后面的数据会覆盖前面的数据

```js
let map = new Map()
let foo = {foo: 'foo'}
map.set(foo, 'foo1')
map.set(foo, 'foo2')
map.get(foo)  // 'foo2' 
```

因为同set使用同样的 [sameValueZero](https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-samevaluezero) 算法，所以对于键名同为 `NaN` 以及相同对象而不同实例的处理同 `Set`

```js
let a = NaN
let b = NaN
let map = new Map()
map.set(a, 'a')
map.set(b, 'b')
map.size    // 1
map.get(a)  // 'b'
```

### 实例属性

`Map.prototype.size`：返回 `Map` 对象的键值对数量；

`Map.prototype.set(key, value)`：设置 `Map` 对象中键的值。返回该 `Map` 对象；

`Map.prototype.get(key)`： 返回键对应的值，如果不存在，则返回 `undefined`；

`Map.prototype.has(key)`：返回一个布尔值，表示 `Map` 实例是否包含键对应的值；

`Map.prototype.delete(key)`： 如果 `Map` 对象中存在该元素，则移除它并返回 `true`；

`Map.prototype.clear()`： 移除 `Map` 对象的所有键/值对；

`Map.prototype.keys()`：返回一个新的 `Iterator` 对象， 它按插入顺序包含了 `Map` 对象中每个元素的键；

`Map.prototype.values()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的值；

`Map.prototype.entries()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的 `[key, value]` 数组；

`Map.prototype.forEach(callbackFn[, thisArg])`：按插入顺序遍历 `Map`；

```js
let map = new Map()
map.set({a: 1}, 'a')
map.set({a: 2}, 'b')
for (let [key, value] of map) {
    console.log(key, value)
}
// {a: 1} 'a'
// {a: 2} 'b'
for (let key of map.keys()) {
    console.log(key)
  // {a: 1}
	// {a: 2}
}
```

## WeakMap

- 类似于 `Map` 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 `WeakMap` 是不能被迭代的。

  ```js
  let wm = new WeakMap()
  let foo = {name: 'foo'}
  wm.set(foo, 'a')  // Weak
  wm.get(foo)       // 'a'
  wm.has(foo)       // true
  ```

  虽然 `wm` 的键对 `foo` 对象有引用，但是丝毫不会阻止 `foo` 对象被 `GC` 回收。当引用对象 `foo` 被垃圾回收之后，`wm` 的 `foo` 键值对也会自动移除，所以不用手动删除引用。

**实例方法**：

- `WeakMap.prototype.delete(key)`：移除 `key` 的关联对象
- `WeakMap.prototype.get(key)`：返回 key 关联对象, 或者 undefined（没有key关联对象时）
- `WeakMap.prototype.has(key)`：根据是否有 `key` 关联对象返回一个 `Boolean` 值
- `WeakMap.prototype.set(key, value)`：在 `WeakMap` 中设置一组 `key` 关联对象，返回这个 `WeakMap` 对象



从这里开始变得抽象了起来，估计要单独花费，15个左右的番茄时间才能掌握，不管了



## Proxy

代理，用来定义基本操作的自定义行为，对target操作之前会先进行拦截

```js
// 创建代理对象，代理对象内有两个对象，一个是target，指向需要监听的对象，另一个是handler，做如何处理
let proxy = new Proxy(target,handler)
// 代理对象的使用
let instance = new Proxy({user:'fall'},{
  // 分别返回的是 代理对象，当前获取的键，整个instance对象
  get(target,propKey,receiver){
    return `你好啊，${target.name}`
  },
  set(target,propKey,receiver){},
  deleteProperty(target,prop){}
})
instance.name // '你好啊，fall'
```

果 `handler` 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上（对代理赋值，直接作用于 target）

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.name = '布兰'
target.name  // '布兰'
```

### 静态方法

`Proxy.revocable()` 定义一个可撤销的Proxy

```js
let target = {}
let handler = {}
let {proxy, revoke} = Proxy.revocable(target, handler)

proxy.foo = 123
proxy.foo  // 123
revoke()
proxy.foo  // TypeError
```

### 示例

示例放在了Reflect的实例中，下面



## Reflect

和 Proxy 相同，Reflect作用是恢复到原来的默认值操作

- `Reflect` 是一个内置的对象，它提供拦截 `JavaScript` 操作的方法。这些方法与 `proxy handlers` 的方法相同。`Reflect` 不是一个函数对象，因此它是不可构造的。
- 设计的目的：
  - 将 `Object` 属于语言内部的方法放到 `Reflect` 上；
  - 修改某些 `Object` 方法的返回结果，让其变得更合理；
  - 让 `Object` 操作变成函数行为
  - `Proxy handles` 与 `Reflect` 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 

### 静态方法

- `Reflect.apply(target, thisArgument, argumentsList)` 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 `Function.prototype.apply()` 功能类似；
- `Reflect.construct(target, argumentsList[, newTarget])` 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`；
- `Reflect.defineProperty(target, propertyKey, attributes)` 和 `Object.defineProperty()` 类似。如果设置成功就会返回 `true`；
- `Reflect.deleteProperty(target, propertyKey)` 作为函数的 `delete` 操作符，相当于执行 `delete target[name]`；
- `Reflect.get(target, propertyKey[, receiver])` 获取对象身上某个属性的值，类似于 `target[name]`；
- `Reflect.getOwnPropertyDescriptor(target, propertyKey)` 类似于 `Object.getOwnPropertyDescriptor()`。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 `undefined`；
- `Reflect.getPrototypeOf(target)` 类似于 `Object.getPrototypeOf()`；
- `Reflect.has(target, propertyKey)` 判断一个对象是否存在某个属性，和 `in` 运算符 的功能完全相同；
- `Reflect.isExtensible(target)` 类似于 `Object.isExtensible()`；
- `Reflect.ownKeys(target)` 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 `Object.keys()`, 但不会受 `enumerable` 影响)；
- `Reflect.preventExtensions(target)` 类似于 `Object.preventExtensions()`。返回一个 `Boolean`；
- `Reflect.set(target, propertyKey, value[, receiver])` 将值分配给属性的函数。返回一个 `Boolean`，如果更新成功，则返回 `true`；
- `Reflect.setPrototypeOf(target, prototype)` 设置对象原型的函数. 返回一个 `Boolean`， 如果更新成功，则返回 `true`；

Proxy和Reflect是成对出现的，所以合起来就有一个示例

### 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般就不用添加这个参数了）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return Reflect.get(target, propKey) // 如果想要使用默认获取值的操作，使用该返回值
  },
  set(target,propKey,receiver){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是赋的值 此处为 23
    // target[propKey] = receiver //在此处意为：将staff.age 设置为 23 
    return Reflect.set(target,propKey,receiver) // 如果想要使用默认获取值的操作，使用该返回值
  },
  deleteProperty(target,propKey){
    console.log(target) 			// target 指向的是 staff 
    console.log(propKey)			// propKey 指向的是 key age
    return Reflect.deleteProperty(target,propKey) // 如果想要使用默认获取值的操作，使用该返回值
  } 
})
delete proxyStaff.age
proxyStaff.age= 23
console.log(proxyStaff.age);
```



## Class

- 可以用 `class` 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把小狗定义为一个类，小狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 `name` 属性

  ```js
  // 类声明
  class Dog {
      constructor(name) {
          this.name = name
      }
      bark() {}
      jump() {}
  }
  Dog.name  // 'Dog'
  
  // 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）
  let Animal2 = class {
      // xxx
  }
  Animal2.name  // 'Animal2'
  复制代码
  ```

- `JS` 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 `ES5` 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：

  ```js
  class Dog {
      constructor() {}
      bark() {}
      jump() {}
  }
  Object.keys(Dog.prototype)  // []
  
  // 类似于
  function Dog2(){
  }
  Dog2.prototype = {
      constructor() {},
      bark() {},
      jump() {},
  }
  Object.keys(Dog2.prototype)  // ['constructor', 'bark', 'jump']
  复制代码
  ```

- 基于原型给类添加新方法：

  ```js
  Object.assign(Dog.prototype, {
      wag() {}  // 摇尾巴
  })
  复制代码
  ```

- 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，`getter`和 `setter` 都在严格模式下执行。

- 类内部的 `this` 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 `this` 指向运行时的环境，而类内部是严格模式，所以此时的 `this` 会是 `undefined`：

  ```js
  class Dog {
      constructor(name) {
          this.name = name
      }
      bark() {
          console.log( `${this.name} is bark.` )
      }
      static jump() {
          console.log( `${this.name} is jump.` )
      }
  }
  let dog = new Dog('大黄')
  let { bark } = dog
  let { jump } = Dog
  bark()  // TypeError: Cannot read property 'name' of undefined
  jump()  // TypeError: Cannot read property 'name' of undefined
  复制代码
  ```

**方法和关键字**：

- `constructor` 方法是类的默认方法，通过 `new` 关键字生成实例的时候，会自动调用；一个类必须有`constructor` 方法，如果没有显示定义，则会自动添加一个空的；`constructor` 默认会返回实例对象：

  ```js
  class Point {}
  
  // 等同于
  class Point {
      constructor() {}
  }
  复制代码
  ```

- 通过 `get` 和 `set` 关键字拦截某个属性的读写操作：

  ```js
  class Dog {
      get age(){
          return 1
      }
      set age(val){
          this.age = val
      }
  }
  复制代码
  ```

- 用 `static` 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：

  ```js
  class Dog {
      bark() {}
      jump() {
          console.log('原型方法')
      }
      static jump() {
          console.log('静态方法')
      }
  }
  Object.getOwnPropertyNames(Dog.prototype)  // ['constructor', 'bark', 'jump']
  Dog.jump()  // '静态方法'
  let dog = new Dog()
  dog.jump()  // '原型方法'
  复制代码
  ```

- 公有字段和私有字段：

  静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：

  ```js
  class Dog {
      age = 12                   // 公有字段
      static sex = 'male'        // 静态公有字段
      #secret = '我是人类的好朋友'  // 私有字段
      #getSecret() {              // 私有方法
          return this.#secret
      }
  }
  Dog.sex  // 'male'
  let dog = new Dog()
  dog.#getSecret()  // SyntaxError
  复制代码
  ```

  > 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。

- `new.target` 属性允许你检测函数、构造方法或者类是否是通过 `new` 运算符被调用的。在通过 `new` 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是 `undefined`，子类继承父类的时候会返回子类：

  ```js
  class Dog {
      constructor() {
          console.log(new.target.name)
      }
  }
  function fn(){
      if (!new.target) return 'new target is undefined'
      console.log('fn is called by new')
  }
  let dog = new Dog()  // 'Dog'
  fn()                 // 'new target is undefined'
  new fn()             // 'fn is called by new'
  复制代码
  ```

**类的继承**：

- 类可以通过 `extends` 关键字实现继承，如果子类显示的定义了 `constructor` 则必须在内部调用 `super()` 方法，内部的 `this` 指向当前子类：

  ```js
  class Animal {
      constructor(name) {
          this.name = name
      }
      run() {
          console.log(`${this.name} is running.`)
      }
  }   
  class Dog extends Animal{
      constructor(name){
          super(name)  // 必须调用
          this.name = name
      }
      bark() {
          console.log(`${this.name} is barking.`)
      }
  
  }
  let dog = new Dog('大黄')
  dog.run()  // '大黄 is running.'
  复制代码
  ```

- 通过 `super()` 调用父类的构造函数或者通过 `super` 调用父类的原型方法；另外也可以在子类的静态方法里通过 `super` 调用父类的静态方法：

  ```js
  // 基于上面的代码改造
  class Dog extends Animal{
      constructor(name){
          super(name)  // 调用父类构造函数
          this.name = name
      }
      bark() {
          super.run()  // 调用父类原型方法
          console.log(`${this.name} is barking.`)
      }
  }
  let dog = new Dog()
  dog.bark()s
  // '大黄 is running.'
  // '大黄 is barking.'
  复制代码
  ```

- 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的prototype属性：

  ```js
  class Animal {}
  class Dog extends Animal {}
  
  Dog.__proto__ === Animal  // true
  Dog.prototype.__proto__ === Animal.prototype  // true
  复制代码
  ```

  子类原型的原型指向父类的原型：

  ```js
  // 基于上面的代码
  let animal = new Animal()
  let dog = new Dog()
  dog.__proto__.__proto__  === animal.__proto__  // true
  复制代码
  ```

- 使用 `extends` 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：

  - `String()`
  - `Number()`
  - `Boolean()`
  - `Array()`
  - `Object()`
  - `Function()`
  - `Date()`
  - `RegExp()`
  - `Error()`

  ```js
  class MyString extends String {
      constructor(name){
          super(name)
          this.name = name
      }
      welcome() {
          return `hello ${this.name}`
      }
  }
  let ms = new MyString('布兰')
  ms.welcome()      // 'hello 布兰'
  ms.length         // 2
  ms.indexOf('兰')  // 1
  ```


作者：大海我来了
链接：https://juejin.cn/post/6895898051559456776
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。