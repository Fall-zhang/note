在移植项目中，搭建Vue框架环境使用vue-cli进行项目的创建，在vant、和element这两个ui组件库的基础上进行修改，实现原本IOS应用实现的界面和功能。利用vue-router配置SPA的界面跳转和路由，ESlint实现统一代码风格。并且通过SVN提交项目代码，进行多人开发。

完整的Web App开发过程中，使用vue2框架进行开发SPA应用，利用echart实现数据的展现，利用localStorage存储数据（正在升级为indexDB的存储），使用VueX，和路由进行组件之间数据的交互，按需导入模块。最后使用cordova进行环境的配置和对应用进行打包和发布。

## 数据结构

数据结构用于展现数据之间的逻辑关系，存储关系，操作关系。

数据结构主要有哪些？

栈，队列，链表，集合，哈希表，树，字典，图。

## BigInt

可以表示大于 `2^53-1` 以上的整数。BigInt可以表示任意大的数字

```js
const num1 = 23n
const num2 = BigInt(66)
```

其他特性

```js
10n == 10 // true
10n === 10 //false
10n > 8 // true
10 + Number(25n) // 35
10 + 20n // TypeError
100n + BigInt(55) // 155n
```

## Array

为内存中多个连续的值存储多个数据的存储控件

### 扩展运算符

数据扩展运算符 `...` 可以展开数组

```js
// 应用一：函数传参
Math.max(...[1, 2, 3])  // 3
// 应用二：数组合并
let merge = [...[1, 2], ...[3, 4], 5, 6]  // 1, 2, 3, 4, 5, 6
// 应用三：浅克隆
let a = [1, 2, 3]
let clone = [...a]
a === clone  // false
// 应用四：数组解构
const [x, ...y] = [1, 2, 3]
x  // 1
y  // [2, 3]
```

如果数组上没有值，ES6 新增语法就会将空位默认替换为 undefined

```js
[...[1, , 3].values()]  // [1, undefined, 3]
```

### 静态方法

`Array.from()` 可以将字符串，类数组对象（ `NodeList`，`arguments`），Set 和可迭代对象转化为数组

```js
// 字符串转数组
Array.from("我搜搜") //  [ "我", "搜", "搜" ]
// 数组合并，去重
let merge = [...[1,2,3],...[1,5,3]]
Array.from(new Set(merge))
function fun(){// 无论传入多少个数据，都可以拼接为数组，然后返回
  return Array.from(arguments) 
}
fun(1,5,6)
// 除此之外，第二个参数可以将每一个数据都进行一次操作
Array.from("我搜搜",x=>x+"_") // ["我_", "搜_", "搜_"]
Array.from({length: 3}, (v, i) => ++i)  // [1, 2, 3] 
```



`Array.of()` 可以将参数转换为数组

`Array.of(1,2,3)` 转换后为 `[1,2,3]` 

**********

### 实例方法

**单个添加删除**

- `Array.prototype.push()` 从末尾进行添加
- `Array.prototype.pop()` 从末尾取出
- `Array.prototype.shift()` 从最开始取出
- `Array.prototype.unshift()` 从最开始插入
- `Array.prototype.concat()` 合并两个数组

```js
// 示例将在下一次更新中补充
```

**从数组中取出数组**

`Array.prototype.splice(start,num,in)`

- start 开始的项
- num 有几项。为零，表示不截取
- in 插入的内容

```js
// 示例将会在后面补充
// 删除
// 插入
// 替换
```

`Array.prototype.slice(start,end)` 

- start 截取的开始位置（可以为负数，表示从后向前，第几位）
- end 截取的结束位置

```js
// 示例将会在后面补充
```

**方法**

- `Array.prototype.map` 映射
- `Array.prototype.filter` 返回值为true的所有成员
- `Array.prototype.reduce` 减少
- `Array.prototype.every` 每一项都返回 true，则返回 true
- `Array.prototype.some` 任意一项为 ture 返回 true
- `Array.prototype.forEach` 无返回值 

```js
let arr = [5,6,4,6,2]
let arr1 = arr.map(item=>item+2) //[ 7, 8, 6, 8, 4 ]
// 对每一个进行操作
let arr2 = arr.filter(item=>item>5) // [ 6, 6 ]
// 返回符合条件的数值
let arr3 = arr.reduce((item1,item2)=>item1+item2) // 23
// 合并为一个数值，item1 是操作后
```

查找下标

`Array.prototype.indexOf(content,index)` 从开始进行查找

`Array.prototype.lastIndexOf()` 从结束位置开始查找

- content 查找的内容
- index 开始的查找点

```js
// 示例待添加
```



**数组的覆盖**

`Array.prototype.copyWithin(i,j,k)` 

- i 必填：从数组的哪个下标开始替换，为负数，从后向前数
- j 可填：开始填充的位置，默认为 0
- k 可填：结束填充的位置，默认为原数组长度

使用当前数组，从组数的第 i 位，开始进行替换(还是举例子更形象一点)

```js
[1,2,3,4,5].copyWithin(2) // [1,2,1,2,3]
[1,2,3,4,5].copyWithin(-2) // [1,2,3,1,2]
[1,2,3,4,5].copyWithin(2,1) // [1,2,2,3,4]
[1,2,3,4,5].copyWithin(2,1,2) // [1,2,2,4,5]
```

**数组的查找**

`Array.prototype.find()` 

```js
[1, 6, 9].find((val, index, arr) => val % 2 === 0) // 返回 val
[1, 6, 9].findIndex((val, index, arr) => val % 2 === 0) // 返回 index
```

`Array.prototype.fill()`  数组中的覆盖

```js
[1,2,3,4,5].fill('2',1,3) 
// 第一个参数，表示传入的字符串
// 第二个参数选填：开始的索引
// 第三个参数选填：结束的索引
```

`Array.prototype.keys()` `Array.prototype.values()` `Array.prototype.entries()`

 ```js
var cc = ["1","2","6","66"]
for(i of cc.keys()){
  console.log(i); // 1,2,3,4
}
for(i of cc.values()){
  console.log(i); // "1","2","6","66"
}
for(i of cc.entries()){
  console.log(i); // [ 0, "1" ] [ 1, "2" ] [ 2, "6" ] [ 3, "66" ]
}
 ```

`Array.prototype.includes()` 是否包含

```js
// 想要查看数组中是否包含 某个元素 x，
// 原来的做法
if([].indexOf(x)>-1){}
if(~[].indexOf(x)){}
// 现在的做法
if(Array.includes(x))
```

并且可以检验数组中是否包含 `NaN`，indexOf使用的是 `===` 全等，无法在遇到 `NaN` 时返回 index

```js
[1, NaN, 3].indexOf(NaN)   // -1
[1, NaN, 3].includes(NaN)  // true
```

**把数组拍平**

`Array.prototype.flat()`

把二维数组，或者是数组中嵌套数组的内容拍平

```js
[1,2,[3,4,[5]]].flat() // [ 1, 2, 3, 4, [5] ]
// 通过 Infinity 可以直接全部展开为一维数组
[1,2,[3,4,[5]]].flat(Infinity) //[ 1, 2, 3, 4, 5 ]
```

**数组排序**

`Array.prototype.reverse() ` 数组倒序

`Array.prototype.sort()` 数组排序

**数组转换**

`Array.prototype.toString()` 转换为字符串返回

`Array.prototype.toLocaleString()` 转换为本地格式字符串返回

`Array.prototype.join()` 用指定的字符分割数组，并转换为字符串



## Set

Set 是一个键值统一的数据结构，可以近似理解为是数组，只不过数组的下标和数组的单项内容相同，可以通过传入一个数组，实现对于数组的构造。

```js
const cc = new Set([1,2,2])
cc // Set([1,2])
const ss = new Set('unique')
ss // Set('u','n','i','q','e')
```

在 `Set` 内部判断两个值是否相等使用的是 `sameValueZero` 算法，需要注意条件和`===`差不多，只有一个例外，`NaN`和`NaN` 会被认为相同。

```js
let cc = new Set([NaN,NaN])
cc.size  // 1
// 只要对象不指向同一个地址，就不会因为重复被筛选掉
var a = {title:'leaf'}
var b = {title:'leaf'}
var c = a
let set1 = new Set()
set1.add(a);set1.add(b);
set1.size // 2
let set2 = new Set()
set2.add(a);set2.add(c)
set2.size // 1
let set3 = new Set()
set3.add(a);set3.add({title:'leaf'})
set3.size   // 2
```

Set 是有顺序的，根据添加的顺序进行排序，通过 `for...of...` 进行遍历

```js
let set = new Set([1,3])
set.add('cs')
set.add('vc')
for(item of set){
  console.log(item)   // 1 3 'cs' "vc"
}
```

### 实例属性

```js
let set = new Set([1,2])
set.add(5)       // 向set内添加内容，返回 set
set.size         // 返回set的个数
set.delete(2)    // 删除元素，成功会返回true
set.has(2)       // 是否拥有 2
set.keys()       // 返回简明的遍历器
set.claer()      // 清空当前Set
```

### 应用场景

数组去重，字符串去重

```js
Array.from(new Set([1,3,4,2,1,3]))  //[1,3,4,2]
[...new Set([1,3,4,2,1,3])]         //[1,3,4,2]

[...new Set('unique')].join('') // uniqe
```

求交集，差集，并集

```js
let a = new Set('asd')
let b = new Set('asc')
let union = new Set([...a,...b])  // 并集
// 交集
let intersect = new Set([...a].filter(x=>b.has(x))) 
// 差集，a-b的差集
let diff = new Set([...a].filter(x=>!b.has(x)))
```

## WeakSet

和Set差不多，但是只能进行存储对象

**和 `Set` 的区别**：

- `WeakSet` 只能是对象的集合，而不能是任何类型的任意值；
- `WeakSet` 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 `WeakSet` 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 `WeakSet` 中没有存储当前对象的列表。正因为这样，`WeakSet` 是不可枚举的，也就没有 `size` 属性，没有 `clear` 和遍历的方法。

- `WeakSet.prototype.add(value)`：添加一个新元素 `value`；
- `WeakSet.prototype.delete(value)`：从该 `WeakSet` 对象中删除 `value` 这个元素；
- `WeakSet.prototype.has(value)`：返回一个布尔值,  表示给定的值 `value` 是否存在于这个 `WeakSet` 中；

## Map

不同于对象，对象的键只能是字符串或者 `Symbol`，而 `Map` 的键可以是任何类型（原始类型、对象或者函数），可以通过 `Map` 构造函数创建一个实例，入参是具有 `Iterator` 接口且每个成员都是一个双元素数组 `[key, value]` 的数据结构：

```js
// Map的声明和添加
const map = new Map()
map.set({},12) // 设置一个键值对，可以通过此方法无线设置键值对
// 并且可以通过二元数组设置为Map
var arr = [['name',"fall"],['age',23]]
const map1 = new Map(arr)
```

### 运算特性

如果键值出现了重复，后面的数据会覆盖前面的数据

```js
let map = new Map()
let foo = {foo: 'foo'}
map.set(foo, 'foo1') // 此处 foo作为键进行使用
map.set(foo, 'foo2')
map.get(foo)  // 'foo2' 
```

因为同 set 使用同样的 [sameValueZero](https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-samevaluezero) 算法，所以对于键名同为 `NaN` 以及相同对象而不同实例的处理同 `Set`

```js
let a = NaN
let b = NaN
let map = new Map()
map.set(a, 'a')
map.set(b, 'b')
map.size    // 1
map.get(a)  // 'b'
```

### 原型方法

`Map.prototype.size`：返回 `Map` 对象的键值对数量

`Map.prototype.set(key, value)`：设置 `Map` 对象中键的值。返回该 `Map` 对象

`Map.prototype.get(key)`： 返回键对应的值，如果不存在，则返回 `undefined`

`Map.prototype.has(key)`：返回一个布尔值，表示 `Map` 实例是否包含键对应的值

`Map.prototype.delete(key)`： 如果 `Map` 对象中存在该元素，则移除它并返回 `true`

`Map.prototype.clear()`： 移除 `Map` 对象的所有键/值对

`Map.prototype.keys()`：返回一个新的 `Iterator` 对象， 它按插入顺序包含了 `Map` 对象中每个元素的键

`Map.prototype.values()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的值

`Map.prototype.entries()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的 `[key, value]` 数组

`Map.prototype.forEach(callbackFn[, thisArg])`：按插入顺序遍历 `Map`

```js
let map = new Map()
map.set({a: 1}, 'a')
map.set({a: 2}, 'b')
for (let [key, value] of map) {
    console.log(key, value) 
}
// {a: 1} 'a'
// {a: 2} 'b'
for (let key of map.keys()) {
    console.log(key)
  // {a: 1}
	// {a: 2}
}
```

## WeakMap

- 类似于 `Map` 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 `WeakMap` 是不能被迭代的。

  ```js
  let wm = new WeakMap()
  let foo = {name: 'foo'}
  wm.set(foo, 'a')  // Weak
  wm.get(foo)       // 'a'
  wm.has(foo)       // true
  ```

  虽然 `wm` 的键对 `foo` 对象有引用，但是丝毫不会阻止 `foo` 对象被 `GC` 回收。当引用对象 `foo` 被垃圾回收之后，`wm` 的 `foo` 键值对也会自动移除，所以不用手动删除引用。

**实例方法**：

- `WeakMap.prototype.delete(key)`：移除 `key` 的关联对象
- `WeakMap.prototype.get(key)`：返回 key 关联对象, 或者 undefined（没有key关联对象时）
- `WeakMap.prototype.has(key)`：根据是否有 `key` 关联对象返回一个 `Boolean` 值
- `WeakMap.prototype.set(key, value)`：在 `WeakMap` 中设置一组 `key` 关联对象，返回这个 `WeakMap` 对象

## Class

### 语法特性

Class 就是 ES6 中创建类的语法糖

可以用 `class` 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把狗定义为一个类，狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 `name` 属性

```js
// 类声明
class Dog {
  constructor(name) { // 在创建对象时会构造一次
    this.name = name
  }
  bark() {}
  jump() {}
}
Dog.name  // 'Dog'

// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）
let Animal2 = class {
  // xxx
}
Animal2.name  // 'Animal2'
```

`JS` 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 `ES5` 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：

```js
class Dog {
  constructor() {}
  bark() {}
  jump() {}
}
Object.keys(Dog.prototype)  // [] 类的内部方法是不可被迭代的

// 类似于
function Dog2(){}
Dog2.prototype = {
  constructor() {},
  bark() {},
  jump() {},
}
Object.keys(Dog2.prototype)  // ['constructor', 'bark', 'jump'] function可以被迭代
```

基于原型给类添加新方法

```js
Object.assign(Dog.prototype, {
    eat() {} 
})
```

- 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，`getter`和 `setter` 都在严格模式下执行。
- 类内部的 `this` 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 `this` 指向运行时的环境，而类内部是严格模式，所以此时的 `this` 会是 `undefined`：

```js
class Dog {
  constructor(name) {
    this.name = name
  }
  bark() {
    console.log( `${this.name} is bark.` )
  }
  static jump() {
    console.log( `${this.name} is jump.` )
  }
}
let dog = new Dog('大黄')
let { bark } = dog
let { jump } = Dog
bark()  // TypeError: Cannot read property 'name' of undefined
jump()  // TypeError: Cannot read property 'name' of undefined
```

### 方法和关键字

`constructor` 方法是类的默认方法，通过 `new` 关键字生成实例的时候，会自动调用；`constructor` 默认会返回实例对象：

```js
class Point {}
// 一个类必须有 constructor 方法，如果没有显示定义，则会自动添加一个空的，同下
class Point {
    constructor() {}
}
```

通过 `get` 和 `set` 关键字拦截某个属性的读写操作：

```js
class Dog {
    get age(){
        return 1
    }
    set age(val){
        this.age = val
    }
}
```

用 `static` 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：

```js
class Dog {
    bark() {}
    jump() {
        console.log('原型方法')
    }
    static jump() {
        console.log('静态方法')
    }
}
Object.getOwnPropertyNames(Dog.prototype)  // ['constructor', 'bark', 'jump']
Dog.jump()  // '静态方法'
let dog = new Dog()
dog.jump()  // '原型方法'
```

`new.target` 属性允许你检测函数、构造方法或者类是否是通过 `new` 运算符被调用的。在通过 `new` 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是 `undefined`，子类继承父类的时候会返回子类：

```js
class Dog {
    constructor() {
        console.log(new.target.name)
    }
}
function fn(){
    if (!new.target) return 'new target is undefined'
    console.log('fn is called by new')
}
let dog = new Dog()  // 'Dog'
fn()                 // 'new target is undefined'
new fn()             // 'fn is called by new'
复制代码
```

**类的继承**：

类可以通过 `extends` 关键字实现继承，如果子类显示的定义了 `constructor` 则必须在内部调用 `super()` 方法，内部的 `this` 指向当前子类：

```js
class Animal {
    constructor(name) {
        this.name = name
    }
    run() {
        console.log(`${this.name} is running.`)
    }
}   
class Dog extends Animal{
    constructor(name){
        super(name)  // 必须调用
        this.name = name
    }
    bark() {
        console.log(`${this.name} is barking.`)
    }

}
let dog = new Dog('大黄')
dog.run()  // '大黄 is running.'
复制代码
```

通过 `super()` 调用父类的构造函数或者通过 `super` 调用父类的原型方法；另外也可以在子类的静态方法里通过 `super` 调用父类的静态方法：

```js
// 基于上面的代码改造
class Dog extends Animal{
    constructor(name){
        super(name)  // 调用父类构造函数
        this.name = name
    }
    bark() {
        super.run()  // 调用父类原型方法
        console.log(`${this.name} is barking.`)
    }
}
let dog = new Dog()
dog.bark()s
// '大黄 is running.'
// '大黄 is barking.'
```

子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的prototype属性：

```js
class Animal {}
class Dog extends Animal {}

Dog.__proto__ === Animal  // true
Dog.prototype.__proto__ === Animal.prototype  // true
```

子类原型的原型指向父类的原型：

```js
// 基于上面的代码
let animal = new Animal()
let dog = new Dog()
dog.__proto__.__proto__  === animal.__proto__  // true
```

使用 `extends` 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：

`String()`、`Number()`、`Boolean()`、`Array()`、`Object()`、`Function()`、`Date()`、`RegExp()`、`Error()`

```js
class MyString extends String {
    constructor(name){
        super(name)
        this.name = name
    }
    welcome() {
        return `hello ${this.name}`
    }
}
let ms = new MyString('布兰')
ms.welcome()      // 'hello 布兰'
ms.length         // 2
ms.indexOf('兰')  // 1
```

### 实验性功能

**公有字段和私有字段**

静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：

```
class Dog {
	age = 12,                   // 公有字段
	static sex = 'male',        // 静态公有字段
	#secret = '我是人类的好朋友'  // 私有字段
	#getSecret() {              // 私有方法
		return this.#secret
	}
}
Dog.sex  // 'male'
let dog = new Dog()
dog.#getSecret()  // SyntaxError
```

> 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。

## Proxy

代理，用来定义基本操作的自定义行为，对被代理对象 `target` 操作之前会先进行拦截。

- 实质上是目标对象`target`的包装
- 可以通过代理对象进行操作，也可以直接对 `target` 进行操作，两者相互独立存在，进行操作
- 只有通过 proxy操作时，才会被预设的方法拦截。直接操作对象，不会受到任何拦截影响。

```js
// 创建代理对象，代理对象内有两个对象，一个是 target，表示被监听对象，另一个是 handler，表示做如何处理
let proxy = new Proxy(target,handler)
// 代理对象的使用
let instance = new Proxy({user:'fall'},{
  get(target,propKey,receiver){
    return `你好啊，${target.name}`
  }
})
// 在对被代理对象操作时，能进行拦截，并且获取的是代理处理后的返回值
instance.name // '你好啊，fall'
```

如果 `handler` 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上（对代理赋值，直接作用于 target）

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.name = '布兰'
target.name  // '布兰'
```

### 方法

`Proxy` 对象上的方法一共有一下好多个

- `get` 用于拦截属性的读取操作
- `set` 用于拦截对象的属性操作
- `has` 拦截 `propKey in proxy` 的操作，表示属性是否存在。
- `deleteProperty ` 拦截 `delete` 操作
- `ownKeys` 拦截 `Object.keys()` `for...in` 等循环
- `getOwnPropertyDescriptor` 获取对象上属性的描述对象时的代理
- `defineProperty` 命名对向上的属性描述时的代理
- `preventExtensions` 设置防止扩展属性是的代理
- `getPrototypeOf` 获取
- `isExtensible` 可否扩展的
- `setPrototypeOf`
- `apply`
- `construct`

```js
let target={
  name:'fall'
}
let proxy = new Proxy(target, {
  get(target,propKey,receiver){},
  // 拦截对象属性的读取，target 指的是被代理的对象，propKey 指受到操作的对象，receiver 表示该 Proxy 代理对象
  set(target,propKey,value,receiver){},
  // 拦截对于对象中属性值的设置，target 指的是被代理的对象，propKey 指受到操作的对象，value表示属性对应的值，receiver 表示该 Proxy 代理对象
  has(target,propKey){},
  // 拦截 propKey in proxy 操作，返回一个布尔值
  deleteProperty(target,propKey){},
  // 拦截删除 propKey 的操作
  ownKeys(target){},
  // 拦截多个Object操作，返回一个数组，数组包括所有值，不同于Object.keys()，可以返回Symbol对象
})
```

### 静态方法

`Proxy.revocable()` 定义一个可撤销的 Proxy

```js
let target = {}
let handler = {}
let {proxy, revoke} = Proxy.revocable(target, handler)

proxy.foo = 123
proxy.foo  // 123
revoke() // 执行结构的第二个方法，就可以撤销该 proxy
proxy.foo  // TypeError
```

### 示例

get 示例 

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般不用添加这个参数）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return 'nothing' // 如果想要使用默认获取值的操作，使用该返回值
  },
})
console.log(proxyStaff.age)
// 如果获取本身不存在的值，则返回 undefined
// 如果定义了 return 'nothing'，那么
proxyStaff.career // 'nothing'
```

set 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  set(target,propKey,value,receiver){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    console.log(receiver)// 指向代理对象，此处指向 proxyStaff
    target[propKey] = value
    // 该关键字不需要 return ，在这里无意义  
  }
})
proxyStaff.age = 23
```

has 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  has(target,propKey){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    return propKey in target 
  }
})
if('age' in proxyStaff){
  console.log(proxyStaff.age)
}
```

deleteProperty 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  deleteProperty(target,propKey){
    return delete proxyStaff.age // 此处只能返回 true & false，表示删除是否成功
  }
})
if('age' in proxyStaff){
  delete proxyStaff.age 
  console.log(proxyStaff)
}
```

ownKeys 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  ownKeys(target){
    return Object.keys(target) 
    // 用于拦截 Object.getOwnPropertyNames()、Object.keys()、Object.getOwnPropertySymbols()、for...in 等循环类操作
  }
})
console.log(Object.keys(proxyStaff))
```

`getOwnPropertyDescriptor` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  getOwnPropertyDescriptor(target,propKey){
    return Object.getOwnPropertyDescriptor(target,propKey) 
    // 用于拦截 Object.getOwnPropertyDescriptor()
  }
})
console.log(Object.getOwnPropertyDescriptor(proxyStaff,'name'))
```

`defineProperty` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  defineProperty(target,propKey,propKeyDesc){
    return Object.defineProperty(target,propKey,propKeyDesc) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
console.log(Object.defineProperty(proxyStaff,'hobby',{value:'beauty'}))
```

`preventExtension` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  preventExtensions(target){
    return Object.preventExtensions(target) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
Object.preventExtensions(proxyStaff)
proxyStaff.age = 23
console.log(proxyStaff.age) // undefined
```

`getPrototypeOf` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  getPrototypeOf(target){
    return Object.getPrototypeOf(target) 
  }
})
console.log(Object.getPrototypeOf(proxyStaff)) 
```

`isExtensible` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  isExtensible(target){
    return Object.isExtensible(target)// 返回一个布尔值，表示是否可以扩展
    // return false  // 直接返回 false 会报错
  }
})
console.log(Object.isExtensible(proxyStaff)) 
```

`setPrototypeOf` 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  setPrototypeOf(target,proto){
    // 设置原型方法会调用该函数
    console.log(`向${target}的上，设置了${proto}原型`);
    return Object.setPrototypeOf(target,proto) 
  }
})
console.log(Object.setPrototypeOf(proxyStaff,{}))
```

apply 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function app(x,y){return x+y}
const proxyStaff = new Proxy(app,{
  apply(target,object,args){
    // object 是 this 参数的指向
    // args 是参数列表
    console.log('调用了该app方法') 
    return app.call(object,...args) 
  }
})
console.log(app(5,6))
```

construct 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function App(x,y){return x+y}
const proxyStaff = new Proxy(App,{
  construct(target,args){
    console.log(args[0]);
    return new App(...args)
  }
})
console.log(new proxyStaff(42,12))
```

## Reflect

和 Proxy 相同，Reflect作用是恢复到原来的默认值操作

- `Reflect` 是一个内置的对象，它提供拦截 `JavaScript` 操作的方法。这些方法与 `proxy handlers` 的方法相同。`Reflect` 不是一个函数对象，因此它是不可构造的。
- 设计的目的：
  - 将 `Object` 属于语言内部的方法放到 `Reflect` 上；
  - 修改某些 `Object` 方法的返回结果，让其变得更合理；
  - 让 `Object` 操作变成函数行为
  - `Proxy handles` 与 `Reflect` 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 

### 静态方法

- `Reflect.apply(target, thisArgument, argumentsList)` 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 `Function.prototype.apply()` 功能类似；
- `Reflect.construct(target, argumentsList[, newTarget])` 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`；
- `Reflect.defineProperty(target, propertyKey, attributes)` 和 `Object.defineProperty()` 类似。如果设置成功就会返回 `true`；
- `Reflect.deleteProperty(target, propertyKey)` 作为函数的 `delete` 操作符，相当于执行 `delete target[name]`；
- `Reflect.get(target, propertyKey[, receiver])` 获取对象身上某个属性的值，类似于 `target[name]`；
- `Reflect.getOwnPropertyDescriptor(target, propertyKey)` 类似于 `Object.getOwnPropertyDescriptor()`。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 `undefined`；
- `Reflect.getPrototypeOf(target)` 类似于 `Object.getPrototypeOf()`；
- `Reflect.has(target, propertyKey)` 判断一个对象是否存在某个属性，和 `in` 运算符 的功能完全相同；
- `Reflect.isExtensible(target)` 类似于 `Object.isExtensible()`；
- `Reflect.ownKeys(target)` 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 `Object.keys()`, 但不会受 `enumerable` 影响)；
- `Reflect.preventExtensions(target)` 类似于 `Object.preventExtensions()`。返回一个 `Boolean`；
- `Reflect.set(target, propertyKey, value[, receiver])` 将值分配给属性的函数。返回一个 `Boolean`，如果更新成功，则返回 `true`；
- `Reflect.setPrototypeOf(target, prototype)` 设置对象原型的函数. 返回一个 `Boolean`， 如果更新成功，则返回 `true`；

Proxy和Reflect是成对出现的，所以合起来就有一个示例

### 示例

```js
// 这段代码中有地方完蛋了，应该是reflect是用错了，看看错在哪了
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般就不用添加这个参数了）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return Reflect.get(target, propKey) // 如果想要使用默认获取值的操作，使用该返回值
  },
  set(target,propKey,value){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    // target[propKey] = receiver //在此处意为：将staff.age 设置为 23 
    return Reflect.set(target,propKey,value) // 如果想要使用默认获取值的操作，使用该返回值
  },
  deleteProperty(target,propKey){
    console.log(target) 			// target 指向的是 staff 
    console.log(propKey)			// propKey 指向的是 key age
    return Reflect.deleteProperty(target,propKey) // 如果想要使用默认获取值的操作，使用该返回值
  } 
})

delete proxyStaff.age
proxyStaff.age= 23
console.log(proxyStaff.age);
```

