## 数据类型


- **Data Types**（六个数据类型） ：undefined、Boolean、Number、String、BigInt、Symbol
- **Structural Types** （两个构造类型）：Object、Function、
- **Structural Root** （一个原始数据类型）：null

## Null & Undefined

### null

表示一个空指针，也是使用 `typeof()` 操作符检测 null 会返回 object 的原因

定义一个变量在将来用于保存对象，那么最好将变量初始化为 null 

js中的数据在底层是以二进制存储，如果前三位为0，那么就会判定为object，而null的所有都为0

### Undefined

如果是 return undefined 等价于什么都没有返回

> 你想使用一个数值：
>
> - `undefined` 表示对这个要取得的值，你什么都没做
> - null证明你把它进行了初始化。

## Boolean

由布尔对象存放的值或者要转换成布尔值的值。

**返回值** 当作为一个构造函数 ( 带有运算符 new ) 调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的Boolean对象。如果作为一个函数(不带有运算符new)调用的，Boolean()只将它的参数转换成一个原始的布尔值，并且返回这个值。

false以及0、NaN、null、空字符串""和undefined都将转换成false。

字符串"false"以及其他的对象和数组都会被转换成true。

## Number类型数据

声明 Number 类型的数据时，可以通过前缀生明，二进制（0b）和八进制（0o）的数据

```js
var a = 1000 // 声明十进制
var b = 0b1011010 // 声明二进制的数据
var c = 0o152437  // 声明八进制的数据
var d = 0x9BC // 声明十六进制的数据
0b1011010 === 90 // true
```

如果计算的数值超过 JavaScript 计算的数值范围，会被自动转换为 `Infinity` 值（有正负之分），比如说`100/0`就是`Infinity`，并且不能参与下一次计算。

### NaN

用来表示一个本来要返回数值的操作数未返回数值的情况避免抛出错误。

比如说，用 `10-"a"` 就是 NaN

- 任何涉及NaN操作，比如`NaN/10`都会返回NaN
- NaN 和任何值都不相等，包括本身(NaN == NaN 为false)

### 静态方法

**判断数值是否有限**

确定一个数是否是有限的，可以使用 `isFinite()` 函数。

```js
Number.isFinite(-2.9)      // true
Number.isFinite(NaN)       // false
Number.isFinite('')        // false
Number.isFinite(false)     // false
Number.isFinite(Infinity)  // false
Number.isFinite('a'/0)     // false
```

**检测是否为NaN**

`Number.isNaN()` 接受一个参数，检测是否为NaN。

```js
Number.isNaN(NaN)    // true
Number.isNaN('a'/0)  // true
Number.isNaN('NaN')  // false
```

**保留指定位数的小数**

将 `num.tofixed(2)` 保留两位有效数字，返回值的类型为 string 

```js
parseInt('12a')  // 12
parseInt('a12')  // NaN
parseInt('')  // NaN
parseInt('0xA')  // 10，0x开头的将会被当成十六进制数
```

**将字符串转化为整数** || **对数据取整**

```js
Number.parseInt('134zc.d') // parseInt 默认使用十进制进行解析字符串 134
Number.parseInt('134zc.d',8) // 以 8 进制的格式解析字符串。输出 10 进制的数
```

**把字符串转换为浮点数**

`Number.parseFloat("63.25ccz2xz")` 转换之后，是63.25

**判断一个数是否是整数**

```js
Number.isInteger(25.0)   // true
Number.isInteger()     // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
Number.isInteger(3.0000000000000002) // true 
// 如果对数据的精度要求非常高，不建议使用
```

**可接受的误差范围**

`Number.EPSILON` 表示数据的可接受误差范围

```js
0.1+0.7 == 0.8 // false 0.1+0.7 在JS中计算结果为0.7999999999999999，两者不相等，所以需要Number.EPSILON
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON  // true
```

**安全数值**

判断一个数值是否在最大安全数值，或者最小安全数值内

```js
Number.MAX_SAFE_INTEGER === 2 ** 53 -1        // true
Number.MAX_SAFE_INTEGER === 9007199254740991  // true
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER  // true
Number.isSafeInteger(2)         // true
Number.isSafeInteger('2')       // false
Number.isSafeInteger(Infinity)  // false
```

### 实例方法

```js
var a = 100
a.toExponential(2) // 科学记数法进行技术，保留两位有效数字，不串值，最多保留14位有效数字
```



## String

### 实例方法

所有的接口都只能返回新的字符串，无法修改原字符串

**大小写转换**

- `str.toUpperCase()`
- `str.toLowerCase()`

**截取字符**

- **获取单个字符**
  - `str.charAt(i)`  得到第 `i` 个字符下标
  - `str.charCodeAt(i)`  第 `i` 个字符的编码
-  **截取多个字符**
  - `str.slice(start,end)`  截取 `[start,end)` 间的数据，支持负数，此时为从后向前截取，不传`end` 则向后截取所有字符。
  - `str.substring(start,end)` 截取 `[start,end) `间的数据,不支持负数
  - `str.substr(start,i)` 从 start 开始截取 `i` 个数据

**查找关键词出现位置** 

`str.indexOf('key',start)` 

从 `start` 开始查找关键词 `key` ，查找失败返回 `-1` ；`start` 可以省略

```js
var str = '从前有一座山，山上有座庙'
console.log(str.indexOf('有',4)) // 基本用法
// 查找最后一个"有"
for (let i = str.length; i > 0; i--) {
  if (str.indexOf('山', i) != -1){
    console.log(str.indexOf('山', i))
    break
  } 
}
```

> 优点：可以指定开始位置
>
> 缺点：不支持正则，只能查找一个关键字
>
> 查找最后一个关键字的 `str.lastIndexOf('keyword')`

**判断关键字是否符合**

`str.search(/正则/)` 

返回关键词位置，找不到返回 `-1` (此方法不支持正则关键字`g`)

**获取所有符合内容**

`str.match(/正则/g)`

找不到则返回 `null` ，找到返回包含所有关键词的数组

**获取下标和内容**

`regexp.exec(str)`

**字符串分割**

`str.split('str')` 

以 `str` 为分隔条件，将字符串分割，如果内容为空，则全部分割。返回值是一个数组

`str.split(/正则/)`

**是否包含特定字符**

```js
let s = 'Hello world!'
s.includes('o')        // true
s.startsWith('Hello')  // true
s.endsWith('!')        // true
```

**重复取值**

```js
// repeat(n) 将当前字符串重复 n 次后，返回一个新字符串：
'x'.repeat(2)         // 'xx'
'x'.repeat(1.9)       // 'x'
'x'.repeat(NaN)       // ''
'x'.repeat(undefined) // ''
'x'.repeat('2a')      // ''
'x'.repeat(-0.6)      // ''，解释：0 ~ 1 之间的小数相当于 0
'x'.repeat(-2)        // RangeError
'x'.repeat(Infinity)  // RangeError
```

### 静态方法

```js
//  String.fromCodePoint() 用于从 Unicode 码点返回对应字符
String.fromCharCode(0x1f600)   // ""
String.fromCodePoint(0x1f600)  // "😀"

// String.raw() 返回将字符串所有变量替换且对斜杠进行转义的结果	
console.log(String.raw`Hi\t\n${2+3}!`); //  Hi\t\n5!

// 	返回字符的十进制码点，对于 Unicode 大于 0xFFFF 的字符，会被认为是2个字符，十进制码点转成十六进制可以使用 toString(16)
let emoji = '🤣'
emoji.length  // 2
emoji.charCodeAt(0).toString(16)  // 'd83d'
emoji.charCodeAt(1).toString(16)  // 'de00'
String.fromCodePoint(0xd83d, 0xde00) === '🤣'  // true
```

## Array

为内存中多个连续的值存储多个数据的存储控件

### 扩展运算符

数据扩展运算符 `...` 可以展开数组

```js
// 应用一：函数传参
Math.max(...[1, 2, 3])  // 3

// 应用二：数组合并
let merge = [...[1, 2], ...[3, 4], 5, 6]  // 1, 2, 3, 4, 5, 6

// 应用三：浅克隆
let a = [1, 2, 3]
let clone = [...a]
a === clone  // false

// 应用四：数组解构
const [x, ...y] = [1, 2, 3]
x  // 1
y  // [2, 3]
```

如果数组上没有值，ES6 新增语法就会将空位默认替换为 undefined

```js
[...[1, , 3].values()]  // [1, undefined, 3]
```

### 静态方法

`Array.from()` 可以将字符串，类数组对象（ `NodeList`，`arguments`），和可迭代对象转化为数组

```js
// 字符串转数组
Array.from("我搜搜") //  [ "我", "搜", "搜" ]
// 数组合并，去重
let merge = [...[1,2,3],...[1,5,3]]
Array.from(new Set(merge))
// arguments 转数组，不知道什么是 argument 可以在 新增特性 的章节查看
function fun(){// 无论传入多少个数据，都可以拼接为数组，然后返回
  return Array.from(arguments) 
}
fun(1,5,6)
// 除此之外，第二个参数可以将每一个数据都进行一次操作
Array.from("我搜搜",x=>x+"_") // ["我_", "搜_", "搜_"]
Array.from({length: 3}, (v, i) => ++i)  // [1, 2, 3] 
```

`Array.of()` 可以将参数转换为数组

`Array.of(1,2,3)` 转换后为 `[1,2,3]` 

### 实例方法

`Array.copyWithin(i,j,k)` 

- i 必填：从数组的哪个下标开始替换，为负数，从后向前数
- j 可填：开始填充的位置，默认为 0
- k 可填：结束填充的位置，默认为原数组长度

使用当前数组，从组数的第 i 位，开始进行替换(还是举例子更形象一点)

```js
[1,2,3,4,5].copyWithin(2) // [1,2,1,2,3]
[1,2,3,4,5].copyWithin(-2) // [1,2,3,1,2]
[1,2,3,4,5].copyWithin(2,1) // [1,2,2,3,4]
[1,2,3,4,5].copyWithin(2,1,2) // [1,2,2,4,5]
```

`Array.find()` 

```js
[1, 6, 9].find((val, index, arr) => val % 2 === 0) // 返回 val
[1, 6, 9].findIndex((val, index, arr) => val % 2 === 0) // 返回 index
```

`Array.fill()`  数组中的覆盖

```js
[1,2,3,4,5].fill('2',1,3) // 第一个参数，表示传入的字符串
// 第二个和第三个参数选填，分别表示：开始的索引和结束的索引
```

`Array.keys()` `Array.values()` `Array.entries()`

 ```js
var cc = ["1","2","6","66"]
for(i of cc.keys()){
  console.log(i); // 1,2,3,66
}
for(i of cc.values()){
  console.log(i); // "1","2","6","66"
}
for(i of cc.entries()){
  console.log(i); // [ 0, "1" ] [ 1, "2" ] [ 2, "6" ] [ 3, "66" ]
}
 ```

## Object类型

对象书写类型的简化

```js
var name = "刘欢"
var obj = {
  name,
  getName(){
    return this.name
  }
}
// 等价于下面的书写方法
var obj = {
	name:"刘欢"，
  getName:function(){
    return this.name
  }
}
```

属性名表达式：在用对象字面量定义对象的时候，允许通过属性名表达式来定义对象属性：

```js
let person = {
  [name]: '布兰',
  name:"小狗",
  ['get' + name]() {
    console.log('获取数据')
    return this.name
  }
}
person[name] // 布兰
person.name // 小狗
```

方法的 `name` 属性

```js
// 所有的方法上面都有 name 属性
// 情况1 
let person = {
	sayHello(){}
}
person.sayHello.name // sayHello
// 情况2
(new Function).name // anonymous
// 情况3

foo.bind({}).name
```

super 关键字，指向对象的原型对象，只能用于对象的方法中，其他地方将报错

```js
let person = {
  name: 'fall',
  getName() {
    return super.name
  }
}
Object.setPrototypeOf(person, {name: 'hello'})
person.getName()
```



### 静态方法

`Object.getOwnPropertyDescriptor(object)`获取对象属性上的描述对象，每个对象属性都有一个描述对象，可以

```js
let person = {name:'布兰',age:12}
Object.getOwnPropertyDescriptor(person,'name')
// {
// configurable: true,
// enumerable: true,
// value: "布兰",
// writable: true
// }
```

**返回键和值**

- `Object.keys` 将所有的 key 作为数组进行返回
- `Object.values` 将所有的 value 作为数组进行

```js
let person = {
  name:'fall',
  operation:'front-end-developer'
}
Object.keys(person).forEach(item=>{
  console.log('key:'+item+'value:'+person[item])
})
```

`Object.assign()` 拷贝对象自身的可枚举类型

```js
const person1 = {
  name:'fall',
  operation:'front-end-developer'
}
const person2 ={
  name:'fall_again',
  goodAt:'joking'
}
Object.assign(person1,person2) // person2 会覆盖 person1，
Object.assign(person2,person1) // 用 person1 区覆盖 person2
// 以 Object.assign(person1,person2) 为例返回的值为 person1
// goodAt: "joking"
// name: "fall_again"
// operation: "front-end-developer"
// 此时person2 为
// {name: "fall_again", goodAt: "joking"}
// 注：属性内部的属性不会生效，即，只拷贝一层
// 并且实行的是浅拷贝，如果源对象某个属性是对象，那么拷贝的是这个对象的引用
```

`Object.is()` 用来判断两个数字是否相等，表现基本和 `===` 一样，一下情况除外

```js
+0 === -0            //true
NaN === NaN          // false
Object.is(+0, -0)    // false
Object.is(NaN, NaN)  // true
```

`Reflect.ownKeys()` 返回对象上的所有属性组成的数组

```js
const person1 = {
  name:'fall',
  operation:'front-end-developer'
}
Reflect.ownKeys(person1) // Array [ "name", "operation" ]
```

`__proto__` 读取和设置当前对象的原型

> 而由于其下划线更多的是表面其是一个内部属性，所以建议不在正式场合使用它，而是用下面的 `Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。

`Object.setPrototypeOf()` 用于设置对象原型，`Object.getPrototypeOf()` 用于读取对象原型：

```js
let person = {name: 'fall'}
Object.setPrototypeOf(person, {name: 'fall_again'})
Object.getPrototypeOf(person)  // {name: 'fall_again'}
```

## Function

### 特殊使用方式

剩余`rest` 参数的传递`...变量名`的形式，用于获取函数的剩余参数，注意 `rest` 参数必须放在最后一个位置，可以很好的代替 `arguments` 对象：

```js
function f(x, ...y) {
    console.log(x)  // 1
    for (let val of y) {
        coonsole.log(val)  // 2 3
    }
}
f(1, 2, 3)
```

**尾调用**：函数的相互调用是会生成“调用帧”的，而“调用帧”里存了各种信息比如函数的内部变量和调用函数的位置等，所有的“调用帧”组成了一个“调用栈”。如果在函数的最后一步操作调用了另外一个函数，因为外层函数里调用位置、内部变量等信息都不会再用到了，所有就无需保留外层函数的“调用帧”了，只要直接用内层函数的“调用帧”取代外层函数的“调用帧”即可：

```js
// 是尾调用
function f(x) {
    return g(x)
}
```

这样一来就很明显的减少了调用栈中的帧数，内存占用就少了，所以这就是尾调用的优化作用。尾递归也是如此，递归如果次数多那就需要保留非常多的“调用帧”，所以经常会出现栈溢出错误，而使用了尾递归优化后就不会发生栈溢出的错误了。

```js
// 常规递归的斐波那契函数
function Fibonacci(n) {
    if ( n <= 1 ) {return 1}
    return Fibonacci(n - 1) + Fibonacci(n - 2)
}
Fibonacci(100) // 超时

// 尾递归优化后的斐波那契函数
function Fibonacci2(n, ac1 = 1, ac2 = 1) {
    if( n <= 1 ) {return ac2}
    return Fibonacci2(n - 1, ac2, ac1 + ac2)
}s
Fibonacci2(100)  // 573147844013817200000
```



**严格模式**：只要函数参数使用了默认值、解构赋值或者扩展运算符，那么函数体内就不能显示的设定为严格模式，因为严格模式的作用范围包含了函数参数，而函数执行的顺序是先执行参数，然后再执行函数体，执行到函数体里的 `use strict` 的时候，那么此时因为函数参数已经执行完成了，那函数参数还要不要受到严格模式的限制呢？这就出现矛盾了。规避限制的办法有两个：设置全局的严格模式或者在函数体外在包一个立即执行函数并且声明严格模式：

```js
// 解法一
'use strict'
function f(x, y = 2) {
}
// 解法二，生成一个立即执行函数
let f = (function(){
    'use strict'
    return function(x, y = 2) {}
})()

```

**箭头函数** 

几种箭头函数写法：

```js
let f1 = () => {}               // 没有参数
let f2 = (x) => {}              // 1个参数
let f3 = x => {}                // 1个参数可以省略圆括号
let f4 = (x, y) => {}           // 2个参数以上必须加上圆括号
let f5 = (x = 1, y = 2) => {}   // 支持参数默认值
let f6 = (x, ...y) => {}        // 支持 rest 参数
let f7 = ({x = 1, y = 2} = {})  // 支持参数解构
let f8 = x => x+7               // 直接 return x+7
let f9 = x =>({name:'fall',bula:x}) // 返回对象时，需要用小括号进行括起来
```

- 箭头函数没有自己的 `this` 指向当前作用域的this
- 也没有自己的 `arguments` 对象
- 箭头函数不能用作构造器，和 `new` 一起用会抛出错误：

```js
function Feo(){} // function 可以作为构造器 new
let feo = new Feo()

let Foo = () => {}
let foo = new Foo() // TypeError: Foo is not a constructor
```

### 实例方法

```js
(function(x,y){return x+y}).length // 2 需要传入参数的个数
(function(x,y=1){return x+y}).length // 1
(function(x=1,y){return x+y}).length // 0 如果一个数初始值，那后面的都会忽略
```

## 参考文章

| 文章名称                                             | 文章地址                                                     |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| 「建议收藏」送你一份精心总结的3万字ES6实用指南（上） | https://juejin.cn/post/6895898051559456776#heading-6         |
| JavaScript 数据类型和数据结构                        | https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures |

