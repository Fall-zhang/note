## 数据结构

数据结构用于展现数据之间的逻辑关系，存储关系，操作关系。

数据结构主要有哪些？

栈，队列，链表，集合，哈希表，树，字典，图。

## Set

Set 是一个键值统一的数据结构，可以近似理解为是数组，只不过数组的下标和数组的单项内容相同，可以通过传入一个数组，实现对于数组的构造。

```js
const cc = new Set([1,2,2])
cc // Set([1,2])
const ss = new Set('unique')
ss // Set('u','n','i','q','e')
```

在 `Set` 内部判断两个值是否相等使用的是 `sameValueZero` 算法，需要注意条件和`===`差不多，只有一个例外，`NaN`和`NaN` 会被认为相同。

```js
let cc = new Set([NaN,NaN])
cc.size  // 1
// 只要对象不指向同一个地址，就不会因为重复被筛选掉
var a = {title:'leaf'}
var b = {title:'leaf'}
var c = a
let set1 = new Set()
set1.add(a);set1.add(b);
set1.size // 2
let set2 = new Set()
set2.add(a);set2.add(c)
set2.size // 1
let set3 = new Set()
set3.add(a);set3.add({title:'leaf'})
set3.size   // 2
```

Set 是有顺序的，根据添加的顺序进行排序，通过 `for...of...` 进行遍历

```js
let set = new Set([1,3])
set.add('cs')
set.add('vc')
for(item of set){
  console.log(item)   // 1 3 'cs' "vc"
}
```

### 实例属性

```js
let set = new Set([1,2])
set.add(5)       // 向set内添加内容，返回 set
set.size         // 返回set的个数
set.delete(2)    // 删除元素，成功会返回true
set.has(2)       // 是否拥有 2
set.keys()       // 返回简明的遍历器
set.claer()      // 清空当前Set
```

### 应用场景

数组去重，字符串去重

```js
Array.from(new Set([1,3,4,2,1,3]))  //[1,3,4,2]
[...new Set([1,3,4,2,1,3])]         //[1,3,4,2]

[...new Set('unique')].join('') // uniqe
```

求交集，差集，并集

```js
let a = new Set('asd')
let b = new Set('asc')
let union = new Set([...a,...b])  // 并集
// 交集
let intersect = new Set([...a].filter(x=>b.has(x))) 
// 差集，a-b的差集
let diff = new Set([...a].filter(x=>!b.has(x)))
```

## WeakSet

和Set差不多，但是只能进行存储对象

**和 `Set` 的区别**：

- `WeakSet` 只能是对象的集合，而不能是任何类型的任意值；
- `WeakSet` 持弱引用：集合中对象的引用为弱引用。如果没有其他的对 `WeakSet` 中对象的引用，那么这些对象会被当成垃圾回收掉。这也意味着 `WeakSet` 中没有存储当前对象的列表。正因为这样，`WeakSet` 是不可枚举的，也就没有 `size` 属性，没有 `clear` 和遍历的方法。

- `WeakSet.prototype.add(value)`：添加一个新元素 `value`；
- `WeakSet.prototype.delete(value)`：从该 `WeakSet` 对象中删除 `value` 这个元素；
- `WeakSet.prototype.has(value)`：返回一个布尔值,  表示给定的值 `value` 是否存在于这个 `WeakSet` 中；

## Map

不同于对象，对象的键只能是字符串或者 `Symbol`，而 `Map` 的键可以是任何类型（原始类型、对象或者函数），可以通过 `Map` 构造函数创建一个实例，入参是具有 `Iterator` 接口且每个成员都是一个双元素数组 `[key, value]` 的数据结构：

```js
// Map的声明和添加
const map = new Map()
map.set({},12) // 设置一个键值对，可以通过此方法无线设置键值对
// 并且可以通过二元数组设置为Map
var arr = [['name',"fall"],['age',23]]
const map1 = new Map(arr)
```

### 运算特性

如果键值出现了重复，后面的数据会覆盖前面的数据

```js
let map = new Map()
let foo = {foo: 'foo'}
map.set(foo, 'foo1')
map.set(foo, 'foo2')
map.get(foo)  // 'foo2' 
```

因为同set使用同样的 [sameValueZero](https://link.juejin.cn/?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23sec-samevaluezero) 算法，所以对于键名同为 `NaN` 以及相同对象而不同实例的处理同 `Set`

```js
let a = NaN
let b = NaN
let map = new Map()
map.set(a, 'a')
map.set(b, 'b')
map.size    // 1
map.get(a)  // 'b'
```

### 原型方法

`Map.prototype.size`：返回 `Map` 对象的键值对数量；

`Map.prototype.set(key, value)`：设置 `Map` 对象中键的值。返回该 `Map` 对象；

`Map.prototype.get(key)`： 返回键对应的值，如果不存在，则返回 `undefined`；

`Map.prototype.has(key)`：返回一个布尔值，表示 `Map` 实例是否包含键对应的值；

`Map.prototype.delete(key)`： 如果 `Map` 对象中存在该元素，则移除它并返回 `true`；

`Map.prototype.clear()`： 移除 `Map` 对象的所有键/值对；

`Map.prototype.keys()`：返回一个新的 `Iterator` 对象， 它按插入顺序包含了 `Map` 对象中每个元素的键；

`Map.prototype.values()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的值；

`Map.prototype.entries()`：返回一个新的 `Iterator` 对象，它按插入顺序包含了 `Map` 对象中每个元素的 `[key, value]` 数组

`Map.prototype.forEach(callbackFn[, thisArg])`：按插入顺序遍历 `Map`；

```js
let map = new Map()
map.set({a: 1}, 'a')
map.set({a: 2}, 'b')
for (let [key, value] of map) {
    console.log(key, value)
}
// {a: 1} 'a'
// {a: 2} 'b'
for (let key of map.keys()) {
    console.log(key)
  // {a: 1}
	// {a: 2}
}
```

## WeakMap

- 类似于 `Map` 的结构，但是键必须是对象的弱引用，注意弱引用的是键名而不是键值，因而 `WeakMap` 是不能被迭代的。

  ```js
  let wm = new WeakMap()
  let foo = {name: 'foo'}
  wm.set(foo, 'a')  // Weak
  wm.get(foo)       // 'a'
  wm.has(foo)       // true
  ```

  虽然 `wm` 的键对 `foo` 对象有引用，但是丝毫不会阻止 `foo` 对象被 `GC` 回收。当引用对象 `foo` 被垃圾回收之后，`wm` 的 `foo` 键值对也会自动移除，所以不用手动删除引用。

**实例方法**：

- `WeakMap.prototype.delete(key)`：移除 `key` 的关联对象
- `WeakMap.prototype.get(key)`：返回 key 关联对象, 或者 undefined（没有key关联对象时）
- `WeakMap.prototype.has(key)`：根据是否有 `key` 关联对象返回一个 `Boolean` 值
- `WeakMap.prototype.set(key, value)`：在 `WeakMap` 中设置一组 `key` 关联对象，返回这个 `WeakMap` 对象

## Class

### 语法特性

Class 就是 ES6 中创建类的语法糖

可以用 `class` 关键字来定义一个类，类是对一类具有共同特征的事物的抽象，就比如可以把狗定义为一个类，狗有名字会叫也会跳；类是特殊的函数，就像函数定义的时候有函数声明和函数表达式一样，类的定义也有类声明和类表达式，不过类声明不同于函数声明，它是无法提升的；类也有 `name` 属性

```js
// 类声明
class Dog {
  constructor(name) { // 在创建对象时会构造一次
    this.name = name
  }
  bark() {}
  jump() {}
}
Dog.name  // 'Dog'

// 类表达式：可以命名（类的 name 属性取类名），也可以不命名（类的 name 属性取变量名）
let Animal2 = class {
  // xxx
}
Animal2.name  // 'Animal2'
```

`JS` 中的类建立在原型的基础上（通过函数来模拟类，其实类就是构造函数的语法糖），和 `ES5` 中构造函数类似，但是也有区别，比如类的内部方法是不可被迭代的：

```js
class Dog {
  constructor() {}
  bark() {}
  jump() {}
}
Object.keys(Dog.prototype)  // [] 类的内部方法是不可被迭代的

// 类似于
function Dog2(){}
Dog2.prototype = {
  constructor() {},
  bark() {},
  jump() {},
}
Object.keys(Dog2.prototype)  // ['constructor', 'bark', 'jump'] function可以被迭代
```

基于原型给类添加新方法

```js
Object.assign(Dog.prototype, {
    eat() {} 
})
```

- 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，`getter`和 `setter` 都在严格模式下执行。
- 类内部的 `this` 默认指向类实例，所以如果直接调用原型方法或者静态方法会导致 `this` 指向运行时的环境，而类内部是严格模式，所以此时的 `this` 会是 `undefined`：

```js
class Dog {
  constructor(name) {
    this.name = name
  }
  bark() {
    console.log( `${this.name} is bark.` )
  }
  static jump() {
    console.log( `${this.name} is jump.` )
  }
}
let dog = new Dog('大黄')
let { bark } = dog
let { jump } = Dog
bark()  // TypeError: Cannot read property 'name' of undefined
jump()  // TypeError: Cannot read property 'name' of undefined
```

### 方法和关键字

`constructor` 方法是类的默认方法，通过 `new` 关键字生成实例的时候，会自动调用；`constructor` 默认会返回实例对象：

```js
class Point {}
// 一个类必须有 constructor 方法，如果没有显示定义，则会自动添加一个空的，同下
class Point {
    constructor() {}
}
```

通过 `get` 和 `set` 关键字拦截某个属性的读写操作：

```js
class Dog {
    get age(){
        return 1
    }
    set age(val){
        this.age = val
    }
}
```

用 `static` 关键字给类定义静态方法，静态方法不会存在类的原型上，所以不能通过类实例调用，只能通过类名来调用，静态方法和原型方法可以同名：

```js
class Dog {
    bark() {}
    jump() {
        console.log('原型方法')
    }
    static jump() {
        console.log('静态方法')
    }
}
Object.getOwnPropertyNames(Dog.prototype)  // ['constructor', 'bark', 'jump']
Dog.jump()  // '静态方法'
let dog = new Dog()
dog.jump()  // '原型方法'
```

`new.target` 属性允许你检测函数、构造方法或者类是否是通过 `new` 运算符被调用的。在通过 `new` 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用。在普通的函数调用中，`new.target` 的值是 `undefined`，子类继承父类的时候会返回子类：

```js
class Dog {
    constructor() {
        console.log(new.target.name)
    }
}
function fn(){
    if (!new.target) return 'new target is undefined'
    console.log('fn is called by new')
}
let dog = new Dog()  // 'Dog'
fn()                 // 'new target is undefined'
new fn()             // 'fn is called by new'
复制代码
```

**类的继承**：

类可以通过 `extends` 关键字实现继承，如果子类显示的定义了 `constructor` 则必须在内部调用 `super()` 方法，内部的 `this` 指向当前子类：

```js
class Animal {
    constructor(name) {
        this.name = name
    }
    run() {
        console.log(`${this.name} is running.`)
    }
}   
class Dog extends Animal{
    constructor(name){
        super(name)  // 必须调用
        this.name = name
    }
    bark() {
        console.log(`${this.name} is barking.`)
    }

}
let dog = new Dog('大黄')
dog.run()  // '大黄 is running.'
复制代码
```

通过 `super()` 调用父类的构造函数或者通过 `super` 调用父类的原型方法；另外也可以在子类的静态方法里通过 `super` 调用父类的静态方法：

```js
// 基于上面的代码改造
class Dog extends Animal{
    constructor(name){
        super(name)  // 调用父类构造函数
        this.name = name
    }
    bark() {
        super.run()  // 调用父类原型方法
        console.log(`${this.name} is barking.`)
    }
}
let dog = new Dog()
dog.bark()s
// '大黄 is running.'
// '大黄 is barking.'
```

子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类；子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的prototype属性：

```js
class Animal {}
class Dog extends Animal {}

Dog.__proto__ === Animal  // true
Dog.prototype.__proto__ === Animal.prototype  // true
```

子类原型的原型指向父类的原型：

```js
// 基于上面的代码
let animal = new Animal()
let dog = new Dog()
dog.__proto__.__proto__  === animal.__proto__  // true
```

使用 `extends` 还可以实现继承原生的构造函数，如下这些构造函数都可以被继承：

`String()`、`Number()`、`Boolean()`、`Array()`、`Object()`、`Function()`、`Date()`、`RegExp()`、`Error()`

```js
class MyString extends String {
    constructor(name){
        super(name)
        this.name = name
    }
    welcome() {
        return `hello ${this.name}`
    }
}
let ms = new MyString('布兰')
ms.welcome()      // 'hello 布兰'
ms.length         // 2
ms.indexOf('兰')  // 1
```

### 实验性功能

**公有字段和私有字段**

静态公有字段和静态方法一样只能通过类名调用；私有属性和私有方法只能在类的内部调用，外部调用将报错：

```
class Dog {
	age = 12,                   // 公有字段
	static sex = 'male',        // 静态公有字段
	#secret = '我是人类的好朋友'  // 私有字段
	#getSecret() {              // 私有方法
		return this.#secret
	}
}
Dog.sex  // 'male'
let dog = new Dog()
dog.#getSecret()  // SyntaxError
```

> 公共和私有字段声明是 JavaScript 标准委员会 TC39 提出的实验性功能（第 3 阶段）。浏览器中的支持是有限的，但是可以通过 Babel 等系统构建后使用此功能。

## Proxy

代理，用来定义基本操作的自定义行为，对被代理对象 `target` 操作之前会先进行拦截。

- 实质上是目标对象`target`的包装
- 可以通过代理对象进行操作，也可以直接对 `target` 进行操作，两者相互独立存在，进行操作
- 只有通过 proxy操作时，才会被预设的方法拦截。直接操作对象，不会受到任何拦截影响。

```js
// 创建代理对象，代理对象内有两个对象，一个是 target，表示被监听对象，另一个是 handler，表示做如何处理
let proxy = new Proxy(target,handler)
// 代理对象的使用
let instance = new Proxy({user:'fall'},{
  get(target,propKey,receiver){
    return `你好啊，${target.name}`
  }
})
// 在对被代理对象操作时，能进行拦截，并且获取的是代理处理后的返回值
instance.name // '你好啊，fall'
```

如果 `handler` 没有设置任何拦截，那么对实例的操作就会转发到目标对象身上（对代理赋值，直接作用于 target）

```js
let target = {}
let proxy = new Proxy(target, {})
proxy.name = '布兰'
target.name  // '布兰'
```

### 方法

`Proxy` 对象上的方法一共有一下好多个

- `get` 用于拦截属性的读取操作
- `set` 用于拦截对象的属性操作
- `has` 拦截 `propKey in proxy` 的操作，表示属性是否存在。
- `deleteProperty ` 拦截 `delete` 操作
- `ownKeys` 拦截 `Object.keys()` `for...in` 等循环
- `getOwnPropertyDescriptor` 获取对象上属性的描述对象时的代理
- `defineProperty` 命名对向上的属性描述时的代理
- `preventExtensions` 设置防止扩展属性是的代理
- `getPrototypeOf` 获取
- `isExtensible` 可否扩展的
- `setPrototypeOf`
- `apply`
- `construct`

```js
let target={
  name:'fall'
}
let proxy = new Proxy(target, {
  get(target,propKey,receiver){},
  // 拦截对象属性的读取，target 指的是被代理的对象，propKey 指受到操作的对象，receiver 表示该 Proxy 代理对象
  set(target,propKey,value,receiver){},
  // 拦截对于对象中属性值的设置，target 指的是被代理的对象，propKey 指受到操作的对象，value表示属性对应的值，receiver 表示该 Proxy 代理对象
  has(target,propKey){},
  // 拦截 propKey in proxy 操作，返回一个布尔值
  deleteProperty(target,propKey){},
  // 拦截删除 propKey 的操作
  ownKeys(target){},
  // 拦截多个Object操作，返回一个数组，数组包括所有值，不同于Object.keys()，可以返回Symbol对象
})
```

### 静态方法

`Proxy.revocable()` 定义一个可撤销的 Proxy

```js
let target = {}
let handler = {}
let {proxy, revoke} = Proxy.revocable(target, handler)

proxy.foo = 123
proxy.foo  // 123
revoke() // 执行结构的第二个方法，就可以撤销该 proxy
proxy.foo  // TypeError
```

### 示例

get 示例 

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般不用添加这个参数）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return 'nothing' // 如果想要使用默认获取值的操作，使用该返回值
  },
})
console.log(proxyStaff.age)
// 如果获取本身不存在的值，则返回 undefined
// 如果定义了 return 'nothing'，那么
proxyStaff.career // 'nothing'
```

set 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  set(target,propKey,value,receiver){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    console.log(receiver)// 指向代理对象，此处指向 proxyStaff
    target[propKey] = value
    // 该关键字不需要 return ，在这里无意义  
  }
})
proxyStaff.age = 23
```

has 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  has(target,propKey){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    return propKey in target 
  }
})
if('age' in proxyStaff){
  console.log(proxyStaff.age)
}
```

deleteProperty 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  deleteProperty(target,propKey){
    return delete proxyStaff.age // 此处只能返回 true & false，表示删除是否成功
  }
})
if('age' in proxyStaff){
  delete proxyStaff.age 
  console.log(proxyStaff)
}
```

ownKeys 示例

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  ownKeys(target){
    return Object.keys(target) 
    // 用于拦截 Object.getOwnPropertyNames()、Object.keys()、Object.getOwnPropertySymbols()、for...in 等循环类操作
  }
})
console.log(Object.keys(proxyStaff))
```

`getOwnPropertyDescriptor` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  getOwnPropertyDescriptor(target,propKey){
    return Object.getOwnPropertyDescriptor(target,propKey) 
    // 用于拦截 Object.getOwnPropertyDescriptor()
  }
})
console.log(Object.getOwnPropertyDescriptor(proxyStaff,'name'))
```

`defineProperty` 方法

```js
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  defineProperty(target,propKey,propKeyDesc){
    return Object.defineProperty(target,propKey,propKeyDesc) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
console.log(Object.defineProperty(proxyStaff,'hobby',{value:'beauty'}))
```

`preventExtension` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  preventExtensions(target){
    return Object.preventExtensions(target) 
    // 用于拦截 Object.defineProperty() propKeyDesc 是可定义的对象的属性
  }
})
Object.preventExtensions(proxyStaff)
proxyStaff.age = 23
console.log(proxyStaff.age) // undefined
```

`getPrototypeOf` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  getPrototypeOf(target){
    return Object.getPrototypeOf(target) 
  }
})
console.log(Object.getPrototypeOf(proxyStaff)) 
```

`isExtensible` 方法

```js
let staff = {
  name:'fall'
}
const proxyStaff = new Proxy(staff,{
  isExtensible(target){
    return Object.isExtensible(target)// 返回一个布尔值，表示是否可以扩展
    // return false  // 直接返回 false 会报错
  }
})
console.log(Object.isExtensible(proxyStaff)) 
```

`setPrototypeOf` 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  setPrototypeOf(target,proto){
    // 设置原型方法会调用该函数
    console.log(`向${target}的上，设置了${proto}原型`);
    return Object.setPrototypeOf(target,proto) 
  }
})
console.log(Object.setPrototypeOf(proxyStaff,{}))
```

apply 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function app(x,y){return x+y}
const proxyStaff = new Proxy(app,{
  apply(target,object,args){
    // object 是 this 参数的指向
    // args 是参数列表
    console.log('调用了该app方法') 
    return app.call(object,...args) 
  }
})
console.log(app(5,6))
```

construct 方法

```js
// 调用 Object.setPrototypeOf() 时，会触发该函数
function App(x,y){return x+y}
const proxyStaff = new Proxy(App,{
  construct(target,args){
    console.log(args[0]);
    return new App(...args)
  }
})
console.log(new proxyStaff(42,12))
```

## Reflect

和 Proxy 相同，Reflect作用是恢复到原来的默认值操作

- `Reflect` 是一个内置的对象，它提供拦截 `JavaScript` 操作的方法。这些方法与 `proxy handlers` 的方法相同。`Reflect` 不是一个函数对象，因此它是不可构造的。
- 设计的目的：
  - 将 `Object` 属于语言内部的方法放到 `Reflect` 上；
  - 修改某些 `Object` 方法的返回结果，让其变得更合理；
  - 让 `Object` 操作变成函数行为
  - `Proxy handles` 与 `Reflect` 方法一一对应，前者用于定义自定义行为，而后者用于恢复默认行为； 

### 静态方法

- `Reflect.apply(target, thisArgument, argumentsList)` 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 `Function.prototype.apply()` 功能类似；
- `Reflect.construct(target, argumentsList[, newTarget])` 对构造函数进行 `new` 操作，相当于执行 `new target(...args)`；
- `Reflect.defineProperty(target, propertyKey, attributes)` 和 `Object.defineProperty()` 类似。如果设置成功就会返回 `true`；
- `Reflect.deleteProperty(target, propertyKey)` 作为函数的 `delete` 操作符，相当于执行 `delete target[name]`；
- `Reflect.get(target, propertyKey[, receiver])` 获取对象身上某个属性的值，类似于 `target[name]`；
- `Reflect.getOwnPropertyDescriptor(target, propertyKey)` 类似于 `Object.getOwnPropertyDescriptor()`。如果对象中存在该属性，则返回对应的属性描述符,  否则返回 `undefined`；
- `Reflect.getPrototypeOf(target)` 类似于 `Object.getPrototypeOf()`；
- `Reflect.has(target, propertyKey)` 判断一个对象是否存在某个属性，和 `in` 运算符 的功能完全相同；
- `Reflect.isExtensible(target)` 类似于 `Object.isExtensible()`；
- `Reflect.ownKeys(target)` 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 `Object.keys()`, 但不会受 `enumerable` 影响)；
- `Reflect.preventExtensions(target)` 类似于 `Object.preventExtensions()`。返回一个 `Boolean`；
- `Reflect.set(target, propertyKey, value[, receiver])` 将值分配给属性的函数。返回一个 `Boolean`，如果更新成功，则返回 `true`；
- `Reflect.setPrototypeOf(target, prototype)` 设置对象原型的函数. 返回一个 `Boolean`， 如果更新成功，则返回 `true`；

Proxy和Reflect是成对出现的，所以合起来就有一个示例

### 示例

```js
// 这段代码中有地方完蛋了，应该是reflect是用错了，看看错在哪了
let staff = {
  name:'fall',
  age:13
}
const proxyStaff = new Proxy(staff,{
  get(target,propKey,receiver){
    console.log(target) // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(receiver) // 指向的是 proxyStaff（一般就不用添加这个参数了）
    // return `谁让你获取这个${propKey}数据的？不给！`
    return Reflect.get(target, propKey) // 如果想要使用默认获取值的操作，使用该返回值
  },
  set(target,propKey,value){
    console.log(target)   // target 指向的是 staff 
    console.log(propKey) // propKey 指向的是 key age
    console.log(value) // 指向的是赋的值 此处为 23
    // target[propKey] = receiver //在此处意为：将staff.age 设置为 23 
    return Reflect.set(target,propKey,value) // 如果想要使用默认获取值的操作，使用该返回值
  },
  deleteProperty(target,propKey){
    console.log(target) 			// target 指向的是 staff 
    console.log(propKey)			// propKey 指向的是 key age
    return Reflect.deleteProperty(target,propKey) // 如果想要使用默认获取值的操作，使用该返回值
  } 
})

delete proxyStaff.age
proxyStaff.age= 23
console.log(proxyStaff.age);
```


