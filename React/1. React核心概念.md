>Create by **fall** on 2021年11月10日11:29:32
>Recently revised in 2021年11月11日11:14:29

## JSX语法相当于

react 代码

```jsx
const element = (
<h1 className="reactTitle">
  Hello World
</h1>
)
```

上面的代码相当于

```js
const element = React.crateElement(
	'h1',
  {className:'greeting'},
  'Hellow World'
)
```

如果要渲染到页面中也相当于

```js
const dom = document.createElement('h1')
dom.innerHtml = `Hello World`
const node = document.querySelector('.reactTitle')
node.appendChild(dom)
```



## 组件的声明方式

一般来讲，所有的组件都有两种声明方式，函数式声明和类式声明。

两种声明方式，对应的也有各自的使用方式。

### 函数式组件

- 函数名称必须大写
- 调用时以标签方式调用，并且开头大写
- 组件参数为 props

```jsx
// function 创建组件
function Welcome(props){
  return (<h1>你好啊{props.name}</h1>)
}
// 特点：接受唯一带有数据的 props (properties)，并且返回了一个 React 元素，本质上就是 JavaScript 函数
```

### 类式组件

- 必须继承 React 的内置类 `Component`
- 必须包含 `render` 方法
- 构造函数 `constructor` 的参数为 `props` ，使用 `props` 时，必须调用 `super(props)`

```jsx
// class 创建组件
class Welcome extends React.component{
  render(){
    return <h1>Hello,{this.props.name}</h1>
  }
}
const element = <Welcome name="Sara"/>;
ReactDOM.render(
	element,
  document.getElementById('root')
)
```

## 三大属性

### state

子组件私有数据

声明只有子组件可以使用的数据

```jsx
class Clock extends ReactDOM.Compont{
  // 通过 constructor 将 props 传递到父类的构造函数中
  constructor(props){
    super(props)
  }
}
```

### props

父组件传递数据

### ref

获取元素的值

## 组件条件渲染

### 防止组件渲染

```jsx
//函数式组件
function WarningBanner(){
  if(props.warn===false){
    return null // 通过返回 null 可以使 function 组件不被渲染
  }
  return (<h1 class="warn">当前界面出现问题</h1>)
}
// 类式组件
class WarnBanner extends React.Component{
  constrcutor(props){
    super(props)
    this.state = {warn:props.warn}
  }
}
```

> 在组件的 `render` 方法中返回 `null` 并不会影响组件的生命周期。

组件的事件绑定

