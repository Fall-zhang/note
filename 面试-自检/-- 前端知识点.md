> Create by **fall** on 18 Oct 2021
> Recently revised in 11 Oct 2023

## 简单

### 从输入一个 URL 地址到浏览器完成渲染的整个过程？

1. 浏览器地址栏输入 URL 并回车
2. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期
3. DNS 解析 URL 对应的 IP
4. 根据 IP 建立 TCP 连接（三次握手）
5. 发送 http 请求
6. 服务器处理请求，浏览器接受 HTTP 响应
7. 浏览器解析并渲染页面
8. 关闭 TCP 连接（四次握手）

> 这个问题属于老生常谈的经典问题了 下面给出面试**简单版**作答，面试官可以基于这道题进行前端很多知识点的考察 从 http 网络知识到浏览器原理再到前端性能优化 这个题目都可以作为引子开始。

### http 状态码

- 204 （无内容） 服务器成功处理了请求，但没有返回任何内容
- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 400 （错误请求） 服务器不理解请求的语法（一般为参数错误）。
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 （禁止） 服务器拒绝请求。（一般为客户端的用户权限不够）
- 404 （未找到） 服务器找不到请求的网页。

### http2.0 做了哪些改进 3.0 呢

**http2.0 特性如下**

- 二进制分帧传输
- 多路复用
- 头部压缩
- 服务器推送

**Http3.0** 相对于 Http2.0 是一种脱胎换骨的改变！

http 协议是应用层协议，都是建立在传输层之上的。我们也都知道传输层上面不只有 TCP 协议，还有另外一个强大的协议 **UDP 协议**，2.0 和 1.0 都是基于 TCP 的，因此都会有 TCP 带来的硬伤以及局限性。而 Http3.0 则是建立在 UDP 的基础上。所以其与 Http2.0 之间有质的不同。

**http3.0 特性如下**

- 连接迁移
- 无队头阻塞
- 自定义的拥塞控制
- 前向安全和前向纠错

> 建议大家详细看看这篇文章[Http2.0 的一些思考以及 Http3.0 的优势](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fm0_60360320%2Farticle%2Fdetails%2F119812431)

### 浏览器缓存策略是怎样的（强缓存 协商缓存）具体是什么过程？

[大前端知识点-浏览器缓存机制](../大前端知识点/4.1-浏览器缓存机制.md)

前端浏览器缓存知识梳理：https://juejin.cn/post/6947936223126093861

### https 加密过程是怎样的

[大前端知识点-HTTPS](../大前端知识点/3.4-HTTPS.md)

### 304 是什么意思一般什么场景出现 ，命中强缓存返回什么状态码

**协商缓存命中返回 304**

这种方式使用到了 headers 请求头里的两个字段，Last-Modified & If-Modified-Since 。服务器通过响应头 Last-Modified 告知浏览器，资源最后被修改的时间：

Last-Modified: Thu, 20 Jun 2019 15:58:05 GMT

当再次请求该资源时，浏览器需要再次向服务器确认，资源是否过期，其中的凭证就是请求头 If-Modified-Since 字段，值为上次请求中响应头 Last-Modified 字段的值：

If-Modified-Since: Thu, 20 Jun 2019 15:58:05 GMT

浏览器在发送请求的时候服务器会检查请求头 request header 里面的 If-modified-Since，如果最后修改时间相同则返回 304，否则给返回头(response header)添加 last-Modified 并且返回数据(response body)。

另外，浏览器在发送请求的时候服务器会检查请求头(request header)里面的 if-none-match 的值与当前文件的内容通过 hash 算法（例如 nodejs: cryto.createHash('sha1')）生成的内容摘要字符对比，相同则直接返回 304，否则给返回头(response header)添加 etag 属性为当前的内容摘要字符，并且返回内容。

综上总结为：

```
请求头last-modified的日期与响应头的last-modified一致
请求头if-none-match的hash与响应头的etag一致
这两种情况会返回Status Code: 304
```

强缓存命中返回 200 

### tree shaking 是什么，原理是什么

Tree shaking 是一种通过**清除多余代码方式**来优化项目打包体积的技术，专业术语叫 Dead code elimination

tree shaking 的**原理**是什么?

```
ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块

静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码
```

> 扩展：common.js 和 es6 中模块引入的区别？

CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：

1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口（静态编译）。

3、CommonJs 是单个值导出，ES6 Module 可以导出多个

4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层

5、CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined

## 中等

### 前端性能定位以及优化指标

前端性能优化 已经是**老生常谈**的一项技术了 很多人说起性能优化方案的时候头头是道 但是真正的对于性能分析定位和性能指标这块却一知半解 所以这道题虽然和性能相关 但是考察点在于平常项目如何进行**性能定位和分析**

1. 我们可以从 前端性能监控-**埋点**以及 **window.performance**相关的 api 去回答
2. 也可以从性能分析工具 Performance 和 **Lighthouse**
3. 还可以从**性能指标** LCP FCP FID CLS 等去着手

> 以下为性能相关的文章 大家可以去看看

[5 分钟撸一个前端性能监控工具](https://juejin.cn/post/6844903662020460552)

[前端性能优化之谈谈通用性能指标及上报策略](https://juejin.cn/post/6844904150057091086)

[前端性能优化指标 + 检测工具](

## 谷歌面试题

- 什么是时间复杂度？为什么它很有用？
- 什么是DOM？
- 什么是事件循环？
- 什么是闭包？
- 原型继承是如何工作的？它和类式继承有什么区别？ (在我看来这不是一个有用的问题,但是很多人喜欢问)
- this 是如何工作的？
- 什么是事件冒泡？它是怎么工作的？ (在我看来这也是一个不好的问题，但是很多人喜欢问)
- 讲一下服务端和客户端通信的方式有哪些，一些高层级的网络协议如何是工作的？（IP, TCP, HTTP/S/2, UDP, RTC, DNS, 等等）
- 什么是 REST？我们为什么要使用它？
- 如果一个网站速度很慢，如何诊断和修复？网站性能优化的方式有哪些？以及这些方式的适用场景。
- 你用过哪些框架？它们的优点和缺点是什么？为什么要使用它们？这些框架解决了哪些问题？