> Create by **fall** on 09 May 2023
> Recently revised in 12 Jun 2023

## Docker

物理机时代->虚拟机时代->容器化时代

是三个不同的软件运行方式

- 物理机时代：多个应用程序可能会跑在一台机器上。
- 虚拟机时代：一台物理机通过虚拟机运行多个环境，环境运行多个程序
- 容器化时代：一台物理机安装多个容器实例，多个实例运行多个程序（比虚拟机更小

### 镜像

镜像（Image）Docker 把应用和依赖放在 image 文件里面，只有通过镜像才能生成容器

image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。

image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。

### 容器

Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个[保护层](https://link.juejin.cn?target=https%3A%2F%2Fopensource.com%2Farticle%2F18%2F1%2Fhistory-low-level-container-runtimes)。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。

由于容器是进程级别的，相比虚拟机有很多优势。

- 启动快：容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。
- 资源占用少：容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。
- 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。

### 用途

**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**它是目前最流行的 Linux 容器解决方案。

Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。

Docker 的主要用途，目前有三大类。

**（1）提供一次性的环境。**比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

**（2）提供弹性的云服务。**因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

**（3）组建微服务架构。**通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

实际使用中，业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救 opers

镜像：将这个包裹东西的内容某一瞬间进行保存，以便从该点之后，进行重复利用

容器：就是一个包裹东西的内容

## 命令

### 镜像

`docker images` 查看所有 docker 镜像（等价于 `docker image ls`）

`docker pull hello-world` 从远程拉取 hello-world 镜像

`docker rmi hello-world` 删除 hello-world 镜像

`docker create <image_name>` 创建一个新的镜像

`docker run <hello-world>` 启动镜像（如果没有，会从网络上下载），额外参数如下

```bash
# 以交互模式运行 ubuntu
docker container run -it ubuntu bash

# 多个配置可以分别书写
docker run --name example -d --env DB_NAME=gitlabhq_production --env DB_USER=gitlab --env DB_PASS=admin_99565 --env --publish 7022:22 DB_EXTENSION=pg_trgm,btree_gist --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql  example:12.22.12
```

- `-i` 以交互模式运行镜像
- `-d` 创建一个守护式容器在后台运行（容器创建后自动在后台运行）
- `-t` 创建启动后会进入其命令行。（加入 `-it` 后，会创建立即登录进入，分配一个伪终端）
- `-name` 为创建的容器命名
- `-v` 表示目录映射关系
- `-p` 表示端口映射（`-p 2022:80` 将容器的 80 端口映射到本地的 2022 端口上）
- `-network=host` 让容器和主机共享一个网络空间

### 容器命令

`docker ps` 查看正在运行的容器

`docker ps -a` 查看所有容器

`docker start <container-name & id>` 启动容器

`docker stop <container-name & id>` 停止容器

`docker kill <container-name & id>` 强制停止容器

`docker restart <container-name & id>` 重启容器

`docker container rm <container-name & id>` 从磁盘中删除容器

### 日志命令

```bash
# 获取容器日志docker
docker container logs <container_id or container_name>
# 监控容器日志
docker container logs -f <container_id or container_name>
```

### 网络命令

```bash
# 列出所有网络
docker network ls
# 创建网络
docker network create --driver <driver-name> <bridge-name>
# 容器连接到网络
docker network connect <network_id or network_name> <container_id or container_name>
# 断开容器和网络的链接
docker network disconnect <network_name_or_id> <container_name_or_id>
# 移除网络
docker network rm <network_id or network_name>
```

### 创建镜像

创建镜像时必须要用到 Dockerfile。Dockerfile 作为一个文本文件来配置 image。context_dir 会使用该 Dockerfile 文件生成二进制的 image 文件。

从 `Dockerfile` 构建 `Docker image`，需要用到 `docker build` 命令

```bash
docker build -t <image_name> <dockerfile>
  
```

- `-t` 是 `-tag` 的缩写，允许镜像指定 image 后面的标签，比如 `redis:6.2`，通常用来区分版本
- `<image_name>` 镜像名称
- `<dockerfile>` dockerfile 文件，指定路径



### 自动化部署

使用`docker` + `jenkins` 能实现代码提交到github后自动部署环境

## 实际上手

获取 postgresql

sameersbn/postgresql:12-20200524

```bash
docker run --name gitlab-postgresql -d --env DB_NAME=gitlabhq_production --env DB_USER=gitlab --env DB_PASS=admin_99565 --env DB_EXTENSION=pg_trgm,btree_gist --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql  sameersbn/postgresql:12-20200524
```

获取 redis 

redis:6.2

```powershell
docker run --name gitlab-redis -d --volume /srv/docker/gitlab/redis:/data redis:6.2
```

使用 gitlab 容器

sameersbn/gitlab:16.0.5

```bash
docker run --name gitlab -d --link gitlab-postgresql:postgresql --link gitlab-redis:redisio --publish 7022:22 --publish 7080:80 --env GITLAB_PORT=7080 --env GITLAB_SSH_PORT=7022  --env GITLAB_SECRETS_DB_KEY_BASE=XGu6XUJ8x4QZ54OSMrvkKzeFHCqm1656Gb3yXZMzp3dJtm2ruio64ZllmtSgvt7pwnhp --env GITLAB_SECRETS_SECRET_KEY_BASE=ISidXCsUtdRRjaTzx7XOBE3rHNRF2qNNEgg9PfKeHSmEsXWfJueJv7M3NEVtUR2gBJAO --env GITLAB_SECRETS_OTP_KEY_BASE=K8KO33Ml85YM8ckm7fYoQyHAufYExMOKbR5jRzjtz8obhRFAsOuGvEy8p7NbneIjFIGC --volume /srv/docker/gitlab/gitlab:/home/git/data  sameersbn/gitlab:16.0.5
```

### docker-compose

```yaml
version: '2.3'

services:
  redis:
    restart: always
    image: redis:6.2.6
    command:
    - --loglevel warning
    volumes:
    - redis-data:/data:Z

  postgresql:
    restart: always
    image: sameersbn/postgresql:12-20200524
    volumes:
    - postgresql-data:/var/lib/postgresql:Z
    environment:
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production
    - DB_EXTENSION=pg_trgm,btree_gist

  gitlab:
    restart: always
    image: sameersbn/gitlab:16.0.5
    depends_on:
    - redis
    - postgresql
    ports:
    - "10080:80"
    - "10022:22"
    volumes:
    - gitlab-data:/home/git/data:Z
    healthcheck:
      test: ["CMD", "/usr/local/sbin/healthcheck"]
      interval: 5m
      timeout: 10s
      retries: 3
      start_period: 5m
    environment:
    - DEBUG=false

    - DB_ADAPTER=postgresql
    - DB_HOST=postgresql
    - DB_PORT=5432
    - DB_USER=gitlab
    - DB_PASS=password
    - DB_NAME=gitlabhq_production

    - REDIS_HOST=redis
    - REDIS_PORT=6379

    - TZ=Asia/Kolkata
    - GITLAB_TIMEZONE=Kolkata

    - GITLAB_HTTPS=false
    - SSL_SELF_SIGNED=false

    - GITLAB_HOST=localhost
    - GITLAB_PORT=10080
    - GITLAB_SSH_PORT=10022
    - GITLAB_RELATIVE_URL_ROOT=
    - GITLAB_SECRETS_DB_KEY_BASE=XGu6XUJ8x4QZ54OSMrvkKzeFHCqm1656Gb3yXZMzp3dJtm2ruio64ZllmtSgvt7pwnhp
    - GITLAB_SECRETS_SECRET_KEY_BASE=ISidXCsUtdRRjaTzx7XOBE3rHNRF2qNNEgg9PfKeHSmEsXWfJueJv7M3NEVtUR2gBJAO
    - GITLAB_SECRETS_OTP_KEY_BASE=K8KO33Ml85YM8ckm7fYoQyHAufYExMOKbR5jRzjtz8obhRFAsOuGvEy8p7NbneIjFIGC

    - GITLAB_ROOT_PASSWORD=
    - GITLAB_ROOT_EMAIL=

    - GITLAB_NOTIFY_ON_BROKEN_BUILDS=true
    - GITLAB_NOTIFY_PUSHER=false

    - GITLAB_EMAIL=notifications@example.com
    - GITLAB_EMAIL_REPLY_TO=noreply@example.com
    - GITLAB_INCOMING_EMAIL_ADDRESS=reply@example.com

    - GITLAB_BACKUP_SCHEDULE=daily
    - GITLAB_BACKUP_TIME=01:00

    - SMTP_ENABLED=false
    - SMTP_DOMAIN=www.example.com
    - SMTP_HOST=smtp.gmail.com
    - SMTP_PORT=587
    - SMTP_USER=mailer@example.com
    - SMTP_PASS=password
    - SMTP_STARTTLS=true
    - SMTP_AUTHENTICATION=login

    - IMAP_ENABLED=false
    - IMAP_HOST=imap.gmail.com
    - IMAP_PORT=993
    - IMAP_USER=mailer@example.com
    - IMAP_PASS=password
    - IMAP_SSL=true
    - IMAP_STARTTLS=false

    - OAUTH_ENABLED=false
    - OAUTH_AUTO_SIGN_IN_WITH_PROVIDER=
    - OAUTH_ALLOW_SSO=
    - OAUTH_BLOCK_AUTO_CREATED_USERS=true
    - OAUTH_AUTO_LINK_LDAP_USER=false
    - OAUTH_AUTO_LINK_SAML_USER=false
    - OAUTH_EXTERNAL_PROVIDERS=

    - OAUTH_CAS3_LABEL=cas3
    - OAUTH_CAS3_SERVER=
    - OAUTH_CAS3_DISABLE_SSL_VERIFICATION=false
    - OAUTH_CAS3_LOGIN_URL=/cas/login
    - OAUTH_CAS3_VALIDATE_URL=/cas/p3/serviceValidate
    - OAUTH_CAS3_LOGOUT_URL=/cas/logout

    - OAUTH_GOOGLE_API_KEY=
    - OAUTH_GOOGLE_APP_SECRET=
    - OAUTH_GOOGLE_RESTRICT_DOMAIN=

    - OAUTH_FACEBOOK_API_KEY=
    - OAUTH_FACEBOOK_APP_SECRET=

    - OAUTH_TWITTER_API_KEY=
    - OAUTH_TWITTER_APP_SECRET=

    - OAUTH_GITHUB_API_KEY=
    - OAUTH_GITHUB_APP_SECRET=
    - OAUTH_GITHUB_URL=
    - OAUTH_GITHUB_VERIFY_SSL=

    - OAUTH_GITLAB_API_KEY=
    - OAUTH_GITLAB_APP_SECRET=

    - OAUTH_BITBUCKET_API_KEY=
    - OAUTH_BITBUCKET_APP_SECRET=
    - OAUTH_BITBUCKET_URL=

    - OAUTH_SAML_ASSERTION_CONSUMER_SERVICE_URL=
    - OAUTH_SAML_IDP_CERT_FINGERPRINT=
    - OAUTH_SAML_IDP_SSO_TARGET_URL=
    - OAUTH_SAML_ISSUER=
    - OAUTH_SAML_LABEL="Our SAML Provider"
    - OAUTH_SAML_NAME_IDENTIFIER_FORMAT=urn:oasis:names:tc:SAML:2.0:nameid-format:transient
    - OAUTH_SAML_GROUPS_ATTRIBUTE=
    - OAUTH_SAML_EXTERNAL_GROUPS=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_EMAIL=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_USERNAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_FIRST_NAME=
    - OAUTH_SAML_ATTRIBUTE_STATEMENTS_LAST_NAME=

    - OAUTH_CROWD_SERVER_URL=
    - OAUTH_CROWD_APP_NAME=
    - OAUTH_CROWD_APP_PASSWORD=

    - OAUTH_AUTH0_CLIENT_ID=
    - OAUTH_AUTH0_CLIENT_SECRET=
    - OAUTH_AUTH0_DOMAIN=
    - OAUTH_AUTH0_SCOPE=

    - OAUTH_AZURE_API_KEY=
    - OAUTH_AZURE_API_SECRET=
    - OAUTH_AZURE_TENANT_ID=

volumes:
  redis-data:
  postgresql-data:
  gitlab-data:
```



### volume

因为容器的数据是不能持久化保存的。所以我们需要用 docker volume 的方式将存储的数据映射到操作系统的目录中来。

## 参考文章

| 作者          | 文章名称                                                     |
| ------------- | ------------------------------------------------------------ |
| 爱笑的架构师  | [5分钟带你快速了解Docker和k8s](https://juejin.cn/post/6913568633813729294) |
| wljslmz       | [Docker小白的福音：50条Docker命令清单，干就完了！](https://juejin.cn/post/7127082572399509511) |
| Rain_or_Shine | [Docker 入门教程-阮一峰](https://juejin.cn/post/6844903561432662023) |
| 天行无忌      | [WEB开发人员应该知道 10 个 Docker 命令](https://juejin.cn/post/7188341548692537402) |
| 杨高超        | [通过 docker 搭建自用的 gitlab 服务](https://juejin.cn/post/6844903544496062472) |
|               |                                                              |

